<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>地灵殿</title>
  
  <subtitle>Frankenstein&#39;s blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-20T09:14:19.232Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Frankenstein</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【类型论】三、Second order typed lambda calculus</title>
    <link href="http://yoursite.com/2021/03/16/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%B8%89%E3%80%81Second-order-typed-lambda-calculus/"/>
    <id>http://yoursite.com/2021/03/16/【类型论】三、Second-order-typed-lambda-calculus/</id>
    <published>2021-03-16T12:41:01.000Z</published>
    <updated>2021-03-20T09:14:19.232Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><h2 id="类型抽象和类型应用（Type-abstraction-and-type-application）"><a href="#类型抽象和类型应用（Type-abstraction-and-type-application）" class="headerlink" title="类型抽象和类型应用（Type-abstraction and type-application）"></a>类型抽象和类型应用（Type-abstraction and type-application）</h2><p>对于<em>抽象</em>这个过程，我们有项$M$，其中可能有自由变量$x$，假设$x$有类型$\sigma$，我们从$M$中抽象$x$，可以得到项$\lambda x : \sigma.M$，同时，所有在$M$中的自由变量$x$被绑定了，我们说：</p><p><em>项$\lambda x:\sigma.M$依赖于项$x$</em>.</p><p>因此，$\lambda{\to}$中可以构造<strong>依赖于项的项</strong>（terms depending on terms）.</p><p>相应的是<em>应用</em>，对于$MN$的构造，我们可以把$M$应用到$N$，也得到一个项.</p><p>这称为<em>一阶</em>（first order）抽象，或一阶依赖，因为这个抽象是在项上进行的. 同时应用也是一阶的.</p><p>现在我们引入<strong>依赖于类型的项</strong>（terms depending on types），称<em>二阶<em>运算（</em>second order</em> operations）或二阶依赖（second order dependency）.</p><p>得到的这一系统称<em>二阶类型lambda演算（second order typed lambda calculus）</em>，或$\lambda 2$.</p><a id="more"></a><p><strong>例：</strong></p><p>首先考虑<em>恒等函数（identity function）</em>，在$\lambda{\to}$中并不存在，因为我们需要一个任意的类型$\alpha$，然后构造$f \equiv \lambda x:\alpha .x$. 但这样，在应用一个自然数类型$nat$的$M$时，我们不能构造$fM$，因为$\alpha \not \equiv nat$，类型不匹配. </p><p>因此对于这样的万能类型，我们需要引入<em>另一层抽象</em>：</p><p>$\lambda \alpha:\ast.\lambda x:\alpha.x$.</p><p>这里变量$\alpha$的类型引入新记号$\ast$，指<em>所有类型的类型（the type of all types）</em>.</p><p>此时$\lambda \alpha:\ast.\lambda x:\alpha.x$也是一个项，但是一个<em>依赖于类型的项（term depending on a type）</em>. 这里依赖的类型是$\alpha$.</p><p>得到的这个项称为<em>多态（polymorphic）</em>恒等函数. 注意这还不是恒等函数本身，我们还需要进行一次（二阶）应用和Beta归约得到一个真正的恒等函数：</p><ul><li>$(\lambda \alpha :\ast.\ \lambda x:\alpha . x)nat \to_\beta \lambda x:nat.x$，为自然数上的恒等函数</li><li>$(\lambda \alpha :\ast.\ \lambda x:\alpha . x)(nat\to bool) \to_\beta \lambda x:(nat\to bool).x$，为$nat\to bool$上的.</li></ul><p>因此我们还需要增加二阶的抽象和应用，以及对于二阶项的Beta归约.</p><h2 id="Pi-类型（-Pi-types）"><a href="#Pi-类型（-Pi-types）" class="headerlink" title="$\Pi$类型（$\Pi$-types）"></a>$\Pi$类型（$\Pi$-types）</h2><p>我们引入<em>二阶lambda抽象（second order $\lambda$-abstraction）</em>或<em>类型抽象（type-abstraction）</em>，例如：</p><p>$\lambda \alpha:*.\lambda x:\alpha.x$.</p><p>在$\lambda{\to}$中，我们猜想它的类型是：</p><p>$\lambda \alpha:\ast.\lambda x:\alpha.x\quad:\quad\ast\to(\alpha\to \alpha)$.</p><p>然而问题是在上面的二阶表达式中，类型$\alpha$变成了一个绑定的变量，我们有理由认为$\lambda \alpha:\ast.\lambda x:\alpha.x$与$\lambda \beta:\ast.\lambda x:\beta.x$相同. 然而$\lambda \alpha:\ast.\lambda x:\alpha.x:\ast\to(\alpha\to\alpha)$，但$\lambda \beta:\ast.\lambda x:\beta.x:\ast\to(\beta\to\beta)$，相同的项有了不同的类型. 这是由于，我们认为左侧的$\alpha$和$\beta$是绑定的变量，而右侧的是自由变量. 因此我们引入一种新绑定：类型绑定（type-binder） 或 $\Pi$绑定（$\Pi$-binder）. 一个将<em>任意</em>类型$\alpha$到类型为$\alpha\to\alpha$的函数的类型记作$\Pi\alpha:\ast.\alpha\to\alpha$.</p><p>我们简单推广$\alpha$变换，有$\Pi\alpha:\ast.\alpha\to\alpha\equiv_\alpha\Pi\beta:\ast.\beta\to\beta$. 此时我们有：</p><p>$$<br>\lambda \alpha:\ast.\lambda x:\alpha.x\quad:\quad\Pi\alpha:\ast.\alpha\to\alpha\<br>\equiv\quad\lambda \beta:\ast.\lambda x:\beta.x\quad:\quad\Pi\beta:\ast.\beta\to\beta<br>$$</p><blockquote><p>在数学中，$\Pi$用于乘积，而$\Pi$类型也称作积类型.</p></blockquote><h2 id="二阶抽象和应用法则（Second-order-abstraction-and-application-rules）"><a href="#二阶抽象和应用法则（Second-order-abstraction-and-application-rules）" class="headerlink" title="二阶抽象和应用法则（Second order abstraction and application rules）"></a>二阶抽象和应用法则（Second order abstraction and application rules）</h2><h3 id="二阶抽象法则（Second-order-abstraction-rule）"><a href="#二阶抽象法则（Second-order-abstraction-rule）" class="headerlink" title="二阶抽象法则（Second order abstraction rule）"></a>二阶抽象法则（Second order abstraction rule）</h3><p>$(abst_2)\ \dfrac{\Gamma,\ \alpha:\ast\ \vdash\ M:A}{\Gamma\ \vdash\ \lambda \alpha:\ast.M\ :\ \Pi\alpha:\ast.A}$</p><p>当上下文中$M$有类型$A$且$\alpha$有类型$\ast$，则$\lambda \alpha:\ \ast.\ M$有类型$\Pi\alpha:\ast\ .A$. 新的地方是：我们允许二阶声明在上下文中.</p><h3 id="二阶应用法则（Second-order-application-rule）"><a href="#二阶应用法则（Second-order-application-rule）" class="headerlink" title="二阶应用法则（Second order application rule）"></a>二阶应用法则（Second order application rule）</h3><p>$(appl_2)\ \dfrac{\Gamma\ \vdash\ M\ :\ \Pi\alpha:\ast.\ A\qquad\Gamma\ \vdash\ B:\ast}{\Gamma\ \vdash\ MB\ :\ A[\alpha:=B]}$</p><h2 id="lambda2-系统（The-system-lambda2-）"><a href="#lambda2-系统（The-system-lambda2-）" class="headerlink" title="$\lambda2$系统（The system $\lambda2$）"></a>$\lambda2$系统（The system $\lambda2$）</h2><p>以下是$\lambda2$的完整定义：</p><h3 id="lambda2-类型（-lambda2-types）"><a href="#lambda2-类型（-lambda2-types）" class="headerlink" title="$\lambda2$类型（$\lambda2$-types）"></a>$\lambda2$类型（$\lambda2$-types）</h3><p>$\mathbb{T2=V|(T2\to T2)|(\Pi V:*.T2)}$，其中$\mathbb{V}$是类型变量集合.</p><h3 id="二阶预定型项（Second-order-pre-typed-lambda-terms-lambda2-terms-Lambda-mathbb-T2-）"><a href="#二阶预定型项（Second-order-pre-typed-lambda-terms-lambda2-terms-Lambda-mathbb-T2-）" class="headerlink" title="二阶预定型项（Second order pre-typed $\lambda$-terms, $\lambda2$-terms, $\Lambda_\mathbb{T2}$）"></a>二阶预定型项（Second order pre-typed $\lambda$-terms, $\lambda2$-terms, $\Lambda_\mathbb{T2}$）</h3><p>$\mathbb{\Lambda_{T2}}=V|(\mathbb{\Lambda_{T2}\Lambda_{T2}})|(\Lambda_\mathbb{T2}\mathbb{T2})|(\lambda V:\mathbb{T2.\Lambda_{T2}})|(\lambda\mathbb{V}:*.\Lambda_\mathbb{T2})$.</p><p>此时我们有两种变量：对象变量（object variables）$V$（如$x,\ y,\ \dots$）和类型变量（type variables）$\mathbb{V}$（如$\alpha,\ \beta,\ \dots$）. 我们有一阶抽象$(\lambda V:\mathbb{T2.\Lambda_{T2}})$和二阶抽象$(\lambda\mathbb{V}:*.\Lambda_\mathbb{T2})$，一阶应用$(\mathbb{\Lambda_{T2}\Lambda_{T2}})$和二阶应用$(\Lambda_\mathbb{T2}\mathbb{T2})$.</p><h3 id="陈述，声明（Statement-declaration）"><a href="#陈述，声明（Statement-declaration）" class="headerlink" title="陈述，声明（Statement, declaration）"></a>陈述，声明（Statement, declaration）</h3><ol><li><em>陈述（statement）</em>要么形如$M:\sigma$，其中$M\in\Lambda_\mathbb{T2}$且$\sigma:\mathbb{T2}$，要么形如$\sigma:\ast$，其中$\sigma \in \mathbb{T2}$.</li><li><em>声明（declaration）</em>是一个以<em>项变量（type variable）</em>或<em>类型变量（term variable）</em>为主体的陈述.</li></ol><p>在$\lambda{\to}$中，<em>上下文</em>只是一个项声明的列表. 在$\lambda2$中，所有变量在被使用之前必须声明. 所以，类型变量$\alpha$（具有类型$\ast$）这个声明必须先于$x:\alpha\to\alpha$这个声明. </p><h3 id="lambda2-上下文、定义域（-lambda2-context-domain-rm-dom-）"><a href="#lambda2-上下文、定义域（-lambda2-context-domain-rm-dom-）" class="headerlink" title="$\lambda2$上下文、定义域（$\lambda2$-context; domain; ${\rm dom}$）"></a>$\lambda2$上下文、定义域（$\lambda2$-context; domain; ${\rm dom}$）</h3><ol><li>$\emptyset$是$\lambda2$上下文；${\rm dom(\emptyset)}=(\ )$，为空列表.</li><li>若$\Gamma$是$\lambda2$上下文，$\alpha\in\mathbb{V}$且$\alpha\not\in{\rm dom}(\Gamma)$，则$\Gamma,\ \alpha:*$是$\lambda2$上下文.</li><li>若$\Gamma$是$\lambda2$上下文，若$\rho \in \mathbb{T2}$使得对$\rho$中的所有自由变量$\alpha$都有$\alpha \in {\rm dom}(\Gamma)$且$x \not \in {\rm dom}(\Gamma)$，则$\Gamma,\ x:\rho$是$\lambda2$上下文.</li></ol><blockquote><p>此定义中蕴含了$\lambda2$上下文中的变量互不相同.</p></blockquote><h3 id="lambda2-的-var-法则（Var-rule-for-lambda2-）"><a href="#lambda2-的-var-法则（Var-rule-for-lambda2-）" class="headerlink" title="$\lambda2$的$(var)$法则（Var-rule for $\lambda2$）"></a>$\lambda2$的$(var)$法则（Var-rule for $\lambda2$）</h3><p>$(var)\quad \Gamma \vdash x:\sigma$，如果$\Gamma$是$\lambda2$上下文且$x:\sigma\in\Gamma$.</p><p>$\lambda2$的$(var)$法则也是没有<strong>前提</strong>的.</p><p>对于$\lambda2$的派生，我们现在有复用$\lambda{\to}$中的$(appl)$和$(abst)$，刚刚定义的$(var)$和新加入的$(appl_2)$和$(abst_2)$.</p><p>然而当使用这五条法则时，我们将无法使用到$(appl_2)$法则，因为它的第二个<strong>前提</strong>是$\Gamma\ \vdash\ B:<em>$，而我们没有规则使得有东西具有类型$</em>$（没有形如$\dots\ \vdash\ \dots\ :\ <em>$的*</em>结论**）.</p><p>直觉告诉我们，$B:*$，只要$B$是个类型且我们已知所有$B$中的类型变量，因此有：</p><h3 id="form-法则（Formation-rule）"><a href="#form-法则（Formation-rule）" class="headerlink" title="$(form)$法则（Formation rule）"></a>$(form)$法则（Formation rule）</h3><p>$(form)\quad\Gamma\ \vdash\ B:*$，如果$\Gamma$是$\lambda2$上下文，$B\in\mathbb{T2}$且所有在$B$中的自由类型变量都在$\Gamma$有声明.</p><blockquote><p>$(form)$法则虽然有三个条件，但也没有<strong>前提</strong>，可以作为派生树的叶子</p></blockquote><p>于是$\lambda2$的所有派生法则：</p><p>$(var)\quad \Gamma \vdash x:\sigma$，如果$\Gamma$是$\lambda2$上下文且$x:\sigma\in\Gamma$.</p><p>$(appl)\ \dfrac{\Gamma\ \vdash\ M:\sigma\to\tau\quad\Gamma\ \vdash\ N:\sigma}{\Gamma\ \vdash\ MN:\tau}$</p><p>$(abst)\ \dfrac{\Gamma,\ x:\sigma\ \vdash\ M:\tau}{\Gamma\ \vdash\ \lambda x:\sigma.\ M\ :\ \sigma\to\tau}$</p><p>$(form)\quad\Gamma\ \vdash\ B:*$，如果$\Gamma$是$\lambda2$上下文，$B\in\mathbb{T2}$且所有在$B$中的自由类型变量都在$\Gamma$有声明.</p><p>$(appl_2)\ \dfrac{\Gamma\ \vdash\ M\ :\ \Pi\alpha:\ast.\ A\qquad\Gamma\ \vdash\ B:\ast}{\Gamma\ \vdash\ MB\ :\ A[\alpha:=B]}$</p><p>$(abst_2)\ \dfrac{\Gamma,\ \alpha:\ast\ \vdash\ M:A}{\Gamma\ \vdash\ \lambda \alpha:\ast.M\ :\ \Pi\alpha:\ast.A}$</p><h3 id="合法的-lambda2-项（Legal-lambda2-terms）"><a href="#合法的-lambda2-项（Legal-lambda2-terms）" class="headerlink" title="合法的$\lambda2$项（Legal $\lambda2$-terms）"></a>合法的$\lambda2$项（Legal $\lambda2$-terms）</h3><p>称$\mathbb{\Lambda_{T2}}$中的项$M$<em>合法</em>（legal），若存在$\lambda2$上下文$\Gamma$和$\mathbb{T2}$类型$\rho$使得$\Gamma\vdash M:\rho$.</p><h2 id="lambda2-中的派生例"><a href="#lambda2-中的派生例" class="headerlink" title="$\lambda2$中的派生例"></a>$\lambda2$中的派生例</h2><p>试图派生$M\equiv\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)$.</p><p>即找到上下文$\Gamma$和类型$\rho$使得$\Gamma\vdash M:\rho$. 因为$M$没有自由项或类型变量，所有可以取$\Gamma\equiv\emptyset$，于是：</p><p>$(n)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\quad:\quad?$</p><p>下一个定型的项是“二阶$\lambda$”，因此使用$(abst_2)$.</p><p>$(m)\quad \alpha:*\ \vdash\ \lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ ?$</p><p>$(n)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ \dots\quad对(m)用(abst_2)$</p><p>新的目标是$\lambda f:\alpha\to\alpha.\ \dots$，是个普通的一阶抽象，使用$(abst)$：</p><p>$(k)\quad\alpha:*,\ f:\alpha\to\alpha,\ x:\alpha\ \vdash\ f(fx)\ :\ ?$</p><p>$(l)\quad\alpha:*,\ f:\alpha\to\alpha\ \vdash\ \lambda x:\alpha.f(fx)\ :\ \dots\quad对（k）用(abst)$</p><p>$(m)\quad\alpha:*\ \vdash\ \lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx)\ :\ \dots\quad对(l)用(abst)$</p><p>$(n)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ \dots\quad对(m)用(abst_2)$</p><p>剩下的就是一个$\lambda{\to}$ 的定型问题，于是给出简略版本：</p><p>$(1)\quad\alpha:*,\ f:\alpha\to\alpha,\ x:\alpha\ \vdash\ fx\ :\ \alpha$</p><p>$(2)\quad\alpha:*,\ f:\alpha\to\alpha,\ x:\alpha\ \vdash\ f(fx)\ :\ \alpha$</p><p>$(3)\quad\alpha:*,\ f:\alpha\to\alpha\ \vdash\ \lambda x:\alpha.f(fx)\ :\ type_1\quad对（2）用(abst)$</p><p>$(4)\quad\alpha:*\ \vdash\ \lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx)\ :\ type_2\quad对(3)用(abst)$</p><p>$(5)\quad\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(f\ x)\ :\ type_3\quad对(4)用(abst_2)$</p><p>最后填入$type_1$，$type_2$和$type_3$，使用$(abst)$和$(abst_2)$法则：</p><p>$type_1\equiv\alpha\to\alpha$</p><p>$type_2\equiv(\alpha\to\alpha)\to\alpha\to\alpha$</p><p>$type_3\equiv\Pi\alpha:*.(\alpha\to\alpha)\to\alpha\to\alpha$</p><p>填入第五行，结论是：</p><p>$(5)\quad\emptyset\vdash\lambda\alpha:\ast.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx):\Pi\alpha:\ast.(\alpha\to\alpha)\to\alpha\to\alpha$.</p><p>由Thinning引理（见下一节），我们可以得到，对于所有$\lambda2$上下文$\Gamma$：</p><p>$(6)\quad\Gamma\vdash\lambda\alpha:\ast.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx):\Pi\alpha:\ast.(\alpha\to\alpha)\to\alpha\to\alpha$.</p><p>假设我们有类型$nat$：</p><p>$(7)\quad\Gamma\vdash nat:*$</p><p>有$(6)$和$(7)$用$(appl_2)$：</p><p>$(8)\quad\Gamma\vdash(\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx))\ nat:(nat\to nat)\to nat\to nat$.</p><p>假设有：</p><p>$(9)\quad\Gamma\vdash suc\ :\ nat\to nat$，</p><p>对$(8)$和$(9)$用$(appl)$：</p><p>$(10)\quad\Gamma\vdash(\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx))\ nat \ suc:nat\to nat$.</p><p>有$\Gamma\vdash two:nat$，得到：</p><p>$(11)\quad\Gamma\vdash(\lambda\alpha:*.\lambda f:\alpha\to\alpha.\lambda x:\alpha.f(fx))\ nat \ suc\ two:nat$.</p><h2 id="lambda2-的性质"><a href="#lambda2-的性质" class="headerlink" title="$\lambda2$的性质"></a>$\lambda2$的性质</h2><h3 id="Alpha替换-Alpha等价推广（α-conversion-α-equivalence-extended）"><a href="#Alpha替换-Alpha等价推广（α-conversion-α-equivalence-extended）" class="headerlink" title="Alpha替换/Alpha等价推广（α-conversion/α-equivalence, extended）"></a>Alpha替换/Alpha等价推广（α-conversion/α-equivalence, extended）</h3><p>（1a）项变量重命名</p><p>$\lambda x:\sigma.M=_\alpha\lambda y:\sigma.M^{x\to y}$如果$y \not\in FV(M)$且$y$不是$M$中的绑定变量.</p><p>（1b）类型变量重命名</p><p>$\lambda \alpha:\ast.M=_\alpha \lambda\beta:\ast.M[\alpha:=\beta]$如果$\beta$不在$M$中出现，</p><p>$\Pi\alpha:\ast.M=_\alpha\Pi\beta:\ast.M[\alpha:=\beta]$如果$\beta$不在$M$中出现.</p><h3 id="mathbb-Lambda-2-项的单步Beta归约（One-step-beta-reduction-to-beta-for-mathbb-Lambda-2-terms）"><a href="#mathbb-Lambda-2-项的单步Beta归约（One-step-beta-reduction-to-beta-for-mathbb-Lambda-2-terms）" class="headerlink" title="$\mathbb{\Lambda_2}$项的单步Beta归约（One-step $\beta$-reduction, $\to_\beta$for $\mathbb{\Lambda_2}$-terms）"></a>$\mathbb{\Lambda_2}$项的单步Beta归约（One-step $\beta$-reduction, $\to_\beta$for $\mathbb{\Lambda_2}$-terms）</h3><p>（1a）一阶：$(\lambda x:\sigma.M)N\to_\beta M[x:=N]$</p><p>（1b）二阶：$(\lambda \alpha:*.M)T\to_\beta M[\alpha:=T]$</p><h3 id="lambda2-中依然成立的引理"><a href="#lambda2-中依然成立的引理" class="headerlink" title="$\lambda2$中依然成立的引理"></a>$\lambda2$中依然成立的引理</h3><ul><li>Free Variables Lemma</li><li>Thinning Lemma</li><li>Condensing Lemma</li><li>Generation Lemma</li><li>Subterm Lemma</li><li>Uniqueness of Types</li><li>Substitution Lemma</li><li>Church–Rosser Theorem</li><li>Subject Reduction</li><li>Strong Normalisation Theorem</li></ul><p>注意唯一不适用的引理是Permutation Lemma，因为对于上下文，后出现的声明可能依赖于前面的。而如果我们改成定义中的$\lambda2$上下文，则就仍然成立.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;类型抽象和类型应用（Type-abstraction-and-type-application）&quot;&gt;&lt;a href=&quot;#类型抽象和类型应用（Type-abstraction-and-type-application）&quot; class=&quot;headerlink&quot; title=&quot;类型抽象和类型应用（Type-abstraction and type-application）&quot;&gt;&lt;/a&gt;类型抽象和类型应用（Type-abstraction and type-application）&lt;/h2&gt;&lt;p&gt;对于&lt;em&gt;抽象&lt;/em&gt;这个过程，我们有项$M$，其中可能有自由变量$x$，假设$x$有类型$\sigma$，我们从$M$中抽象$x$，可以得到项$\lambda x : \sigma.M$，同时，所有在$M$中的自由变量$x$被绑定了，我们说：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;项$\lambda x:\sigma.M$依赖于项$x$&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;因此，$\lambda{\to}$中可以构造&lt;strong&gt;依赖于项的项&lt;/strong&gt;（terms depending on terms）.&lt;/p&gt;
&lt;p&gt;相应的是&lt;em&gt;应用&lt;/em&gt;，对于$MN$的构造，我们可以把$M$应用到$N$，也得到一个项.&lt;/p&gt;
&lt;p&gt;这称为&lt;em&gt;一阶&lt;/em&gt;（first order）抽象，或一阶依赖，因为这个抽象是在项上进行的. 同时应用也是一阶的.&lt;/p&gt;
&lt;p&gt;现在我们引入&lt;strong&gt;依赖于类型的项&lt;/strong&gt;（terms depending on types），称&lt;em&gt;二阶&lt;em&gt;运算（&lt;/em&gt;second order&lt;/em&gt; operations）或二阶依赖（second order dependency）.&lt;/p&gt;
&lt;p&gt;得到的这一系统称&lt;em&gt;二阶类型lambda演算（second order typed lambda calculus）&lt;/em&gt;，或$\lambda 2$.&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】二、Simply typed lambda calculus</title>
    <link href="http://yoursite.com/2021/03/06/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%BA%8C%E3%80%81Simply-typed-lambda-calculus/"/>
    <id>http://yoursite.com/2021/03/06/【类型论】二、Simply-typed-lambda-calculus/</id>
    <published>2021-03-06T12:21:00.000Z</published>
    <updated>2021-03-13T12:08:51.364Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><h2 id="简单类型（Simple-types）"><a href="#简单类型（Simple-types）" class="headerlink" title="简单类型（Simple types）"></a>简单类型（Simple types）</h2><p>我们从一个<strong>类型变量</strong>（type variables）的无限集开始：$\mathbb{V}=\lbrace \alpha,\beta,\gamma,…\rbrace$.</p><h3 id="所有简单类型的集合-mathbb-T"><a href="#所有简单类型的集合-mathbb-T" class="headerlink" title="所有简单类型的集合$\mathbb{T}$"></a>所有简单类型的集合$\mathbb{T}$</h3><ol><li>类型变量（Type variable）若$\alpha \in \mathbb{V}$，则$\alpha \in \mathbb{T}$</li><li>箭头类型（Arrow type）若$\sigma,\tau \in \mathbb{T}$，则$(\sigma \to \tau) \in \mathbb{T}$</li></ol><p>即 $\mathbb{T= V\ |\ T \to T}$ .</p><a id="more"></a><p>记法：使用字母$\alpha,\beta,…$表示$\mathbb{V}$中的类型变量，$\sigma,\tau,…$（有时也用$A,B,…$）表示一个简单类型. 最外侧的括号可以省略. 箭头是右结合的.</p><p>“项$M$有类型$\tau$”，我们引入<strong>定型陈述</strong>（statements, or typing statements），形式为$M:\tau$.</p><p>我们假设对于每个类型都有无穷的变量，且每个变量的类型都是唯一的，即若$x:\sigma$且$x:\tau$，则$\sigma \equiv \tau$.</p><p>对于lambda演算的构造方法，有：</p><ol><li>应用：若$M:\sigma \to \tau$且$N:\sigma$，则$M\ N:\tau$.</li><li>抽象：若$x:\sigma$且$M:\tau$，则$\lambda x.M:\sigma \to \tau$</li></ol><h3 id="可定型的项（Typable-term）"><a href="#可定型的项（Typable-term）" class="headerlink" title="可定型的项（Typable term）"></a>可定型的项（Typable term）</h3><p>我们说一个项$M$可定型，如果存在类型$\sigma$使得$M:\sigma$.</p><h2 id="Church定型与Curry定型（Church-typing-and-Curry-typing）"><a href="#Church定型与Curry定型（Church-typing-and-Curry-typing）" class="headerlink" title="Church定型与Curry定型（Church-typing and Curry-typing）"></a>Church定型与Curry定型（Church-typing and Curry-typing）</h2><p>对于定型，有两种方法：</p><h3 id="Church定型（Typing-a-la-Church）"><a href="#Church定型（Typing-a-la-Church）" class="headerlink" title="Church定型（Typing à la Church）"></a>Church定型（Typing à la Church）</h3><p>假设$x$有类型$\alpha \to \alpha$，且$y$有类型$(\alpha \to \alpha) \to \beta$，则$yx$有类型$\beta$. 然后$z$有类型$\beta$，且$u$有类型$\gamma$，则$\lambda zu.z$有类型$\beta \to \gamma \to \beta$. 所以，如果$(\lambda zu.z)(yx)$是允许的，则有类型$\gamma \to \beta$.</p><h3 id="Curry定型（Typing-a-la-Curry）"><a href="#Curry定型（Typing-a-la-Curry）" class="headerlink" title="Curry定型（Typing à la Curry）"></a>Curry定型（Typing à la Curry）</h3><p>对于lambda项$M \equiv (\lambda zu.z)(yx)$，假设变量$x,y,z,u$的类型并没有给出. 我们注意到$M$是一个$\lambda zu.z$对$yx$的应用，所以$\lambda zu.z$应该有一个函数类型，比如$A \to B$，且$yx$必须有类型$A$，所以$M$有类型$B$. </p><p>$\lambda zu.z:A \to B$表明$z:A$且$\lambda u.z:B$. 对于后一个类型陈述，$B$是一个$\lambda$开头抽象的项，因此$B$具有函数类型$B\equiv (C \to D)$，且$u:C,z:D$. </p><p>而$yx$是一个应用，因此一定有$y:E \to F$且$x:E$，则$yx:F$. </p><p>我们有：</p><ul><li>$x:E$</li><li>$y:E\to F$</li><li>$z:A 且 z:D，所以A\equiv D$</li><li>$u:C$</li><li>$B\equiv (C \to D)$</li><li>$yx:A 且yz:F，所以A \equiv F$</li></ul><p>得到$(*)\ x:E,y:E\to A,z:A,u:C$.</p><p>我们可以将变量$x,y,z,u$赋予“真实”的类型，填入$(*)$式的样板，如：</p><ul><li>$x:\beta, y:\beta \to \alpha, z:\alpha,u:\delta, M:\delta \to \alpha$</li><li>$x:\alpha \to \alpha,y:(\alpha \to \alpha)\to \beta,z:\beta,u:\gamma,M:\gamma \to \beta$</li><li>$x:\alpha,y:\alpha\to \alpha \to \beta, z:\alpha \to \beta,u:\alpha \to \alpha$</li></ul><p>我们对于绑定的变量直接给出类型，自由变量的类型称为<strong>上下文</strong>（context）.</p><p>对于项$(\lambda zu.z)(yx)$，$z,u$是绑定的，而$x,y$是自由的. 假设$z:\beta$且$u:\gamma$，我们记作$(\lambda z:\beta.\lambda u:\gamma.z)(yx)$.</p><p>对于此例的上下文，记作：</p><p>$x:\alpha \to \alpha,y:(\alpha \to \alpha) \to \beta \ \vdash\  (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to \beta$.</p><h2 id="Church的-lambda-to-的派生法则"><a href="#Church的-lambda-to-的派生法则" class="headerlink" title="Church的$\lambda{\to}$的派生法则"></a>Church的$\lambda{\to}$的派生法则</h2><h3 id="预标注类型的lambda项（Pre-typed-λ-terms-Lambda-mathbb-T-）"><a href="#预标注类型的lambda项（Pre-typed-λ-terms-Lambda-mathbb-T-）" class="headerlink" title="预标注类型的lambda项（Pre-typed λ-terms,$\Lambda_\mathbb{T}$）"></a>预标注类型的lambda项（Pre-typed λ-terms,$\Lambda_\mathbb{T}$）</h3><p>$\Lambda_\mathbb{T}=V|(\Lambda_\mathbb{T}\Lambda_\mathbb{T})|(\lambda V:\mathbb{T}.\Lambda_\mathbb{T})$.</p><h3 id="陈述，声明，上下文，推断（Statement-declaration-context-judgement）"><a href="#陈述，声明，上下文，推断（Statement-declaration-context-judgement）" class="headerlink" title="陈述，声明，上下文，推断（Statement, declaration, context, judgement）"></a>陈述，声明，上下文，推断（Statement, declaration, context, judgement）</h3><ol><li><strong>陈述</strong>（statement）具有形式$M:\sigma$，其中$M \in \Lambda_\mathbb{T}$且$\sigma \in \mathbb{T}$. 在陈述中，称$M$主体（subject），$\sigma$为类型.</li><li><strong>声明</strong>（declaration）是以变量为主体的陈述.</li><li><strong>上下文</strong>（context）是一个对于<em>不同</em>主体的声明的列表.</li><li><strong>推断</strong>（judgement）具有形式$\Gamma \ \vdash \ M:\sigma$，其中$\Gamma$是上下文，而$M:\sigma$是陈述.</li></ol><p>我们需要判断一个推断是否是可派生的，引入<strong>派生系统</strong>（derivation system）.</p><p><strong>前提-结论格式</strong>（premiss–conclusion format）：</p><p>$\dfrac{前提1\ 前提2\ …\ 前提n}{结论}$</p><p>由此给出Church的$\lambda{\to}$的三条派生法则，以此建立Church的$\lambda{\to}$的派生系统.</p><h3 id="Church的-lambda-to-的派生法则（Derivation-rules-for-lambda-to-）"><a href="#Church的-lambda-to-的派生法则（Derivation-rules-for-lambda-to-）" class="headerlink" title="Church的$\lambda{\to}$的派生法则（Derivation rules for $\lambda{\to}$）"></a>Church的$\lambda{\to}$的派生法则（Derivation rules for $\lambda{\to}$）</h3><p>$(var)\qquad \Gamma\  \vdash\ x:\sigma 若x:\sigma\in \Gamma$</p><p>$(appl)\ \dfrac{\Gamma\ \vdash \ M:\sigma\to\tau\qquad \Gamma\ \vdash\ N:\sigma}{\Gamma\ \vdash\ MN:\tau}$</p><p>$(abst)\ \dfrac{\Gamma,x:\sigma\ \vdash\ M:\tau}{\Gamma \ \vdash\ \lambda x:\sigma.M:\sigma\to\tau}$</p><p>基于派生系统可标注类型的项称<strong>合法的</strong>（legal）.</p><h3 id="合法的-lambda-to-项（Legal-lambda-to-terms）"><a href="#合法的-lambda-to-项（Legal-lambda-to-terms）" class="headerlink" title="合法的$\lambda{\to}$项（Legal $\lambda{\to}$-terms）"></a>合法的$\lambda{\to}$项（Legal $\lambda{\to}$-terms）</h3><p>在$\lambda{\to}$中，一个预标注类型的lambda项$M$是<strong>合法的</strong>，如果存在上下文$\Gamma$和类型$\rho$使得$\Gamma \vdash M:\rho$.</p><h2 id="类型论需要解决的几类问题"><a href="#类型论需要解决的几类问题" class="headerlink" title="类型论需要解决的几类问题"></a>类型论需要解决的几类问题</h2><h3 id="良类型性-可定型性（Well-typedness-Typability）"><a href="#良类型性-可定型性（Well-typedness-Typability）" class="headerlink" title="良类型性/可定型性（Well-typedness/Typability）"></a>良类型性/可定型性（Well-typedness/Typability）</h3><p>形如：</p><p>$?\  \vdash\  项:\ ?$</p><p>即判断一个项是否合法，如果合法则找到一个合适的上下文和类型，否则找出它出错的地方.</p><p>一个变体是<strong>类型赋值</strong>（Type Assignment），即给出上下文，只要找出项的类型：</p><p>$上下文\ \vdash\ 项\ :\ ?$.</p><h3 id="类型检查（Type-Checking）"><a href="#类型检查（Type-Checking）" class="headerlink" title="类型检查（Type Checking）"></a>类型检查（Type Checking）</h3><p>$上下文\ \overset{?}{\vdash}\ 项\ :\ 类型$</p><p>给出上下文、项和类型，检查是否这个项（在这个上下文中）有这个类型.</p><h3 id="项的寻找（Term-Finding-Term-Construction-Inhabitation）"><a href="#项的寻找（Term-Finding-Term-Construction-Inhabitation）" class="headerlink" title="项的寻找（Term Finding/Term Construction/Inhabitation）"></a>项的寻找（Term Finding/Term Construction/Inhabitation）</h3><p>$上下文\ \vdash\ ?\ :\ 类型$</p><p>给定上下文和类型，寻找是否存在合适的项.</p><h2 id="lambda-to-中的良类型性"><a href="#lambda-to-中的良类型性" class="headerlink" title="$\lambda{\to}$中的良类型性"></a>$\lambda{\to}$中的良类型性</h2><p>例：项$M\equiv \lambda y:\alpha \to \beta .\lambda z:\alpha.yz$是否合法. 即找到上下文$\Gamma$和类型$\rho$，使得$\Gamma \vdash M:\rho$.</p><p>首先$\Gamma\equiv\emptyset$就可以，因为$M$中没有自由变量需要定型. 其次就是找到$\rho$：</p><p>$(n)\quad \lambda y.\alpha \to \beta.\lambda z:\alpha.yz\ :\ ?$</p><p>由三条派生法则中，只有抽象法则$(abst)$可以用，这样就变成了：</p><p>$\quad\vdots$</p><p>$(m)\quad y:\alpha \to \beta\ \vdash\ \lambda z:\alpha.yz\ :\ ?$</p><p>$(n)\quad \lambda y:\alpha\to \beta.\lambda z:\alpha.yz:\dots\qquad 对(m)用(abst)$</p><p>这样问题就变成了$(m)$中的$?$. 需要找到$\lambda z:\alpha.yz$的类型，同样是$\lambda$，重复上面的操作：</p><p>$\quad\vdots$</p><p>$(l)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\  yz\ :\ ?$</p><p>$(m)\quad y:\alpha \to \beta \ \vdash\ \lambda z:\alpha.yz\ :\ \dots \qquad对(l)用(abst)$</p><p>$(n)\quad \lambda y:\alpha\to \beta.\lambda z:\alpha.yz:\dots\qquad 对(m)用(abst)$</p><p>新的要定型的项是$yz$，是一个应用，所以只能用应用法则$(appl)$. 而$(appl)$有两个前提，所以现在有两个新目标：</p><p>$\quad\vdots$</p><p>$(k_1)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\ y\ :\ ?_1$</p><p>$\quad \vdots$</p><p>$(k_2)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\ z\ :\ ?_2$</p><p>$(l)\quad y:\alpha \to \beta,\ z:\alpha \ \vdash\  yz\ :\ \dots \qquad 对(k_1)和(k_2)用(appl)$</p><p>$(m)\quad y:\alpha \to \beta \ \vdash\ \lambda z:\alpha.yz\ :\ \dots \qquad对(l)用(abst)$</p><p>$(n)\quad \lambda y:\alpha\to \beta.\lambda z:\alpha.yz:\dots\qquad 对(m)用(abst)$</p><p>现在的目标是$y$和$z$，它们是简单的<em>变量</em>，因此用变量法则$(var)$就完了. 接下来对于$(l)$的项$yz$，由于$(appl)$的条件满足了就可以得到它的类型$\beta$. 接下来的项的类型也都可以这样得到.</p><p>最终得出的结论是我们找到了一个派生，说明$\lambda y:\alpha \to \beta:\alpha.yz$是合法的.</p><h2 id="lambda-to-中的类型检查"><a href="#lambda-to-中的类型检查" class="headerlink" title="$\lambda{\to}$中的类型检查"></a>$\lambda{\to}$中的类型检查</h2><p>例：$x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta$.</p><p>我们的目标是填入下面的点点点：</p><p>$\quad\vdots$</p><p>$(n)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta$</p><p>因为项$(\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta$是一个应用项，我们使用应用法则$(appl)$.</p><p>$\quad\vdots$</p><p>$(m_1)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ \lambda z:\beta.\lambda u:\gamma.z\ :\ ?_1$</p><p>$\quad\vdots$</p><p>$(m_2)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ yx\ :\ ?_2$</p><p>$(n)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta \quad对(m_1)和(m_2)用(appl),(?)$</p><p>因为$(appl)$法则只有在对应的类型匹配上了才成立，所以最后一行还留了个$(?)$.</p><p>对于$?_2$可以用两次$(var)$法则然后$(appl)$法则解决，并且$y$和$x$的类型也匹配得上. 现在还剩：</p><p>$\quad\vdots$</p><p>$(m_1)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ \lambda z:\beta.\lambda u:\gamma.z\ :\ ?$</p><p>对于两个$\lambda$可以使用两次$(abst)$法则解决，就得到了完整的派生：</p><p>$(a) \quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta,\ u:\gamma \ \vdash\ x:\alpha$<br>$(b) \quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta,\ u:\gamma \ \vdash\ y:(\alpha \to \alpha)\to \beta$<br>$(1) \quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta,\ u:\gamma \ \vdash\ z:\beta$</p><p>$(2)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta,\ z:\beta \ \vdash\ \lambda u:\gamma.z:\gamma \to \beta \quad 对(1)用(abst)$</p><p>$(m_1)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ \lambda z:\beta.\lambda u:\gamma.z\ :\ \beta \to\gamma\to\beta \quad 对(2)用(abst)$</p><p>$(m_2)\  x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta \ \vdash\ yx\ :\beta \quad 对(b)和(a)用(appl)$</p><p>$(n)\quad x:\alpha \to \alpha,\ y:(\alpha \to \alpha)\to \beta\ \vdash\ (\lambda z:\beta.\lambda u:\gamma.z)(yx):\gamma \to\beta \quad对(m_1)和(m_2)用(appl),(?)$</p><p>接下来只剩下检查$(n)$ 的$(appl)$ 的条件，显然满足了. 于是我们给出了这个推断的正确派生.</p><h2 id="lambda-to-中项的寻找"><a href="#lambda-to-中项的寻找" class="headerlink" title="$\lambda{\to}$中项的寻找"></a>$\lambda{\to}$中项的寻找</h2><p>在逻辑表达式中，我们有$A \to B \to A$，其中的$\to$读作“蕴含”，这个命题是一个“重言式”. 这很显然，因为：如果A，那么（如果B那么A）.</p><p>我们可以用$\lambda{\to}$形式化这个证明，把$A\to B\to A$作为一个类型，尝试找到一个在空上下文中的项：</p><p>$(n)\quad ?\ :\ A\to B\to A$</p><p>需要一个$\to$类型的项，所以首先用$(abst)$法则：</p><p>$(m)\quad x:A \ \vdash\ ?\ :\ B\to A$</p><p>$(n)\quad \dots\ :\ A\to B\to A\qquad 对(m)用(abst)$</p><p>现在仍然是一个$\to$类型的项，引入新变量$y$重复这个过程：</p><p>$(l)\quad x:A,\ y:B\ \vdash\ ?\ :\ A$</p><p>$(m)\quad x:A \ \vdash\ ?\ :\ B\to A\qquad 对(l)用(abst)$</p><p>$(n)\quad \dots\ :\ A\to B\to A\qquad 对(m)用(abst)$</p><p>现在$?$可以被$(var)$法则解决：</p><p>$(1)\quad x:A,\ y:B\ \vdash\ x\ :\ A$</p><p>$(2)\quad x:A \ \vdash\ \lambda y:B.\ x\ :\ B\to A\qquad 对(1)用(abst)$</p><p>$(3)\quad \lambda x:A.\ \lambda y:B.\ x\ :\ A\to B\to A\qquad 对(2)用(abst)$</p><p>就完成了. </p><p>我们将命题看做类型，把命题的inhabitants作为<em>证明</em>：</p><p>$假设x是命题A的证明，y是命题B的证明.$</p><p>$(1)\quad 那么x（仍）是A的证明.$</p><p>$(2)\quad y到x的函数是一个由B到A的证明，即\lambda y:B.\ x证明了B\to A这个蕴含.$</p><p>$(3)\quad 所以，\lambda x:A.\lambda y:B\ x证明了A\to B\to A.$</p><p>这一过程称<strong>PAT-解释</strong>（PAT-interpretation），“PAT”既指“命题作为类型”（propositions-as-types），又指“证明作为项”（proofs-as-term）. </p><h2 id="lambda-to-的性质"><a href="#lambda-to-的性质" class="headerlink" title="$\lambda{\to}$的性质"></a>$\lambda{\to}$的性质</h2><h3 id="定义域，子上下文，置换，投影（Domain-rm-dom-subcontext-subseteq-permutation-projection-upharpoonright-）"><a href="#定义域，子上下文，置换，投影（Domain-rm-dom-subcontext-subseteq-permutation-projection-upharpoonright-）" class="headerlink" title="定义域，子上下文，置换，投影（Domain, $\rm dom$, subcontext, $\subseteq$, permutation, projection, $\upharpoonright$）"></a><strong>定义域，子上下文，置换，投影</strong>（Domain, $\rm dom$, subcontext, $\subseteq$, permutation, projection, $\upharpoonright$）</h3><ol><li>如果$\Gamma \equiv x_1 : \sigma_1,\dots,x_n:\sigma_n$，则$\Gamma$的<strong>定义域</strong>（domain）或$\rm dom(\Gamma)$为列表$(x_1,\dots,x_n)$.</li><li>上下文$\Gamma’$是$\Gamma$ 的<strong>子上下文</strong>（subcontext），或$\Gamma’ \subseteq \Gamma$，如果$\Gamma’$中所有的声明也在$\Gamma$中以相同次序出现.</li><li>上下文$\Gamma’$是上下文$\Gamma$的一个<strong>置换</strong>（permutation），如果所有在$\Gamma’$中的声明也在$\Gamma$中出现，反之亦然.</li><li>如果$\Gamma$是一个上下文，$\Phi$是一个变量的集合，则$\Gamma$在$\Phi$上的<strong>投影</strong>（projection）或$\Gamma \upharpoonright\Phi$，是$\Gamma$的一个子上下文$\Gamma’$，满足${\rm dom}(\Gamma’) = {\rm dom}(\Gamma)\cap\Phi$.</li></ol><h3 id="自由变量引理-Free-Variables-Lemma"><a href="#自由变量引理-Free-Variables-Lemma" class="headerlink" title="自由变量引理 (Free Variables Lemma)"></a><strong>自由变量引理</strong> <em>(Free Variables Lemma)</em></h3><p>若$\Gamma \vdash L:\sigma$，则$FV(L)\subseteq {\rm dom}(\Gamma)$.</p><p>这说明，如果$L$有类型，则所有在$L$中出现的自由变量$x$都有类型，且作为一条声明$x:\sigma$记录在上下文$\Gamma$中.</p><h3 id="引理-Thinning-Condensing-Permutation"><a href="#引理-Thinning-Condensing-Permutation" class="headerlink" title="引理(Thinning, Condensing, Permutation)"></a>引理<em>(Thinning, Condensing, Permutation)</em></h3><ol><li>（Thinning）令$\Gamma’$与$\Gamma’’$是上下文，使得$\Gamma’ \subseteq \Gamma’’$. 若$\Gamma’ \vdash M:\sigma$则$\Gamma’’ \vdash M:\sigma$.</li><li>（Condensing）若$\Gamma \vdash M:\sigma$，则$\Gamma \upharpoonright FV(M) \vdash M:\sigma$.</li><li>（Permutation）若$\Gamma \vdash M:\sigma$，且$\Gamma’$是$\Gamma$的一个permutation，则$\Gamma’$也是上下文，且$\Gamma’ \vdash M:\sigma$.</li></ol><ul><li>Thinning指一个上下文加上更多声明的扩展，即与<em>子上下文</em>相反. </li><li>Condensing指仅需要保留$\Gamma$中关于$FV(M)$的部分就可以得到$M$的类型.</li><li>Permutation指上下文的顺序并不重要，上下文中的声明并没有相互依赖关系.</li></ul><p>因此在$\lambda{\to}$中，也可以用集合代替列表定义上下文，集合上下文称<strong>基</strong>（bases）. 我们用列表因为对于更复杂的系统还会有依赖的声明，此时顺序就很重要.</p><h3 id="生成引理（Generation-Lemma）"><a href="#生成引理（Generation-Lemma）" class="headerlink" title="生成引理（Generation Lemma）"></a>生成引理（Generation Lemma）</h3><ol><li>若$\Gamma \vdash x:\sigma$，则$x:\sigma \in \Gamma$.</li><li>若$\Gamma \vdash MN:\tau$，则存在类型$\sigma$使得$\Gamma \vdash M:\sigma \to \tau$且$\Gamma \vdash N:\sigma$.</li><li>若$\Gamma\vdash \lambda x:\sigma.M:\rho$，则存在$\tau$使得$\Gamma,\ x:\sigma\vdash M:\tau$且$\rho \equiv \sigma \to \tau$.</li></ol><p>就对应了三条派生法则.</p><h3 id="子项引理（Subterm-Lemma）"><a href="#子项引理（Subterm-Lemma）" class="headerlink" title="子项引理（Subterm Lemma）"></a>子项引理（Subterm Lemma）</h3><p>若$M$是合法的，则$M$的所有子项都是合法的.</p><h3 id="类型唯一性（Uniqueness-of-Types）"><a href="#类型唯一性（Uniqueness-of-Types）" class="headerlink" title="类型唯一性（Uniqueness of Types）"></a>类型唯一性（Uniqueness of Types）</h3><p>设$\Gamma \vdash M:\sigma$且$\Gamma \vdash M : \tau$，则$\sigma \equiv \tau$.</p><h3 id="可判定性定理"><a href="#可判定性定理" class="headerlink" title="可判定性定理"></a>可判定性定理</h3><p>(Decidability of Well-typedness, Type Assignment, TypeChecking and Term Finding)</p><p>在$\lambda{\to}$中，以下问题都是可判定的：</p><ol><li>Well-typedness（1a）Type Assignment</li><li>Type Checking</li><li>Term Finding</li></ol><h2 id="归约和-lambda-to"><a href="#归约和-lambda-to" class="headerlink" title="归约和$\lambda{\to}$"></a>归约和$\lambda{\to}$</h2><p>对于$\lambda{\to}$中的beta归约，我们对代换的定义进行以下调整：</p><ol start="3"><li>$(\lambda y:\sigma.P)[x:=N]\equiv \lambda z:\sigma.(P^{y \to z}[x:=N])$，若$\lambda z:\sigma.P^{y \to z}$是$\lambda y:\sigma.P$的alpha变形使得$z \notin FV(N)$.</li></ol><p>此时我们有：</p><h3 id="代换引理（Substitution-Lemma）"><a href="#代换引理（Substitution-Lemma）" class="headerlink" title="代换引理（Substitution Lemma）"></a>代换引理（Substitution Lemma）</h3><p>设$\Gamma’,\ x:\sigma,\ \Gamma’’ \vdash M:\tau$且$\Gamma’ \vdash N:\sigma$，则$\Gamma’,\Gamma’’ \vdash M[x:=N]:\tau$.</p><h3 id="对-mathbb-Lambda-T-的单步beta归约（-to-beta-for-mathbb-Lambda-T-）"><a href="#对-mathbb-Lambda-T-的单步beta归约（-to-beta-for-mathbb-Lambda-T-）" class="headerlink" title="对$\mathbb{\Lambda_T}$的单步beta归约（$\to_\beta$, for $\mathbb{\Lambda_T}$）"></a>对$\mathbb{\Lambda_T}$的单步beta归约（$\to_\beta$, for $\mathbb{\Lambda_T}$）</h3><ol><li>(Basis) $(\lambda x:\sigma.M)N\to_\beta M[x:=N]$</li><li>(Compatibility)同第一章定义</li></ol><h3 id="Church–Rosser定理"><a href="#Church–Rosser定理" class="headerlink" title="Church–Rosser定理"></a>Church–Rosser定理</h3><p>在$\lambda{\to}$上仍成立</p><h3 id="主体归约引理（Subject-Reduction）"><a href="#主体归约引理（Subject-Reduction）" class="headerlink" title="主体归约引理（Subject Reduction）"></a>主体归约引理（Subject Reduction）</h3><p>若$\Gamma \vdash \sigma : \rho$且若$L \twoheadrightarrow_\beta L’$，则$\Gamma \vdash L’:\rho$.</p><p>即beta归约不影响类型性，且对项进行beta归约不影响项的类型. </p><h3 id="强标准定理-终止定理（Strong-Normalisation-Theorem-Termination-Theorem）"><a href="#强标准定理-终止定理（Strong-Normalisation-Theorem-Termination-Theorem）" class="headerlink" title="强标准定理/终止定理（Strong Normalisation Theorem/Termination Theorem）"></a>强标准定理/终止定理（Strong Normalisation Theorem/Termination Theorem）</h3><p>所有合法的项$M$都是强标准化的.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>$\lambda{\to}$中没有自应用（self-application）</li><li>Beta范式的存在性得以保证</li><li>不是所有合法的项都有不动点</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;简单类型（Simple-types）&quot;&gt;&lt;a href=&quot;#简单类型（Simple-types）&quot; class=&quot;headerlink&quot; title=&quot;简单类型（Simple types）&quot;&gt;&lt;/a&gt;简单类型（Simple types）&lt;/h2&gt;&lt;p&gt;我们从一个&lt;strong&gt;类型变量&lt;/strong&gt;（type variables）的无限集开始：$\mathbb{V}=\lbrace \alpha,\beta,\gamma,…\rbrace$.&lt;/p&gt;
&lt;h3 id=&quot;所有简单类型的集合-mathbb-T&quot;&gt;&lt;a href=&quot;#所有简单类型的集合-mathbb-T&quot; class=&quot;headerlink&quot; title=&quot;所有简单类型的集合$\mathbb{T}$&quot;&gt;&lt;/a&gt;所有简单类型的集合$\mathbb{T}$&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;类型变量（Type variable）若$\alpha \in \mathbb{V}$，则$\alpha \in \mathbb{T}$&lt;/li&gt;
&lt;li&gt;箭头类型（Arrow type）若$\sigma,\tau \in \mathbb{T}$，则$(\sigma \to \tau) \in \mathbb{T}$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即 $\mathbb{T= V\ |\ T \to T}$ .&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【类型论】一、Untyped lambda calculus</title>
    <link href="http://yoursite.com/2021/03/06/%E3%80%90%E7%B1%BB%E5%9E%8B%E8%AE%BA%E3%80%91%E4%B8%80%E3%80%81Untyped-lambda-calculus/"/>
    <id>http://yoursite.com/2021/03/06/【类型论】一、Untyped-lambda-calculus/</id>
    <published>2021-03-06T07:23:46.000Z</published>
    <updated>2021-03-06T11:59:44.518Z</updated>
    
    <content type="html"><![CDATA[<p>本文为<em>Type Theory and Formal Proof : An Introduction</em> 的笔记，纯个人向（</p><hr><p>对于函数的抽象，有两个构造方法和一个计算规则：</p><p><strong>抽象（Abstraction）</strong></p><p>由一个表达式$M$和一个变量$x$ 可以构造表达式$\lambda x.M$，称为$M$上$x$的<strong>抽象（abstraction of x over M）</strong></p><p><strong>应用（Application）</strong></p><p>由表达式$M$和$N$可以构造表达式$M\ N$，称为$M$对$N$的<strong>应用（application of M to N）</strong></p><p><strong>Beta化简（β-reduction）</strong></p><p>形如$(\lambda x.M)N$的表达式可以被改写成$M[x:=N]$，意思是表达式中的$M$中的每个$x$换成$N$，这一过程称为由$(\lambda x.M)N$到$M[x:=N]$的<strong>Beta化简（β-reduction）</strong>.</p><p><strong>注意</strong>“应用”仅是构造另一个lambda项的过程，而真正得到结果的过程则是“Beta化简”.</p><p>以下是严格定义</p><a id="more"></a><h2 id="Lambda项（Lambda-term）"><a href="#Lambda项（Lambda-term）" class="headerlink" title="Lambda项（Lambda-term）"></a><strong>Lambda项（Lambda-term）</strong></h2><p>设$\Lambda$为所有<strong>Lambda项</strong>的集合，我们有一个<strong>变量</strong>的无限集 $V$，$V=\lbrace x,y,z,…\rbrace$</p><ol><li>（变量Variable）若$u \in V$，则$u \in \Lambda$</li><li>（应用Application）若$M,N \in \Lambda$，则$(M\ N)\in \Lambda$</li><li>（抽象Abstraction）若$u \in V$且$M \in \Lambda$，则$(\lambda u.\ M)\in \Lambda$</li></ol><p>我们使用小写字母表示$V$中的变量，用大写的字母表示$\Lambda$中的项.</p><p>如果两个lambda项$M$和$N$相同（syntactical identity），记为$M \equiv N$.</p><h2 id="子项（Subterm）"><a href="#子项（Subterm）" class="headerlink" title="子项（Subterm）"></a>子项（Subterm）</h2><p>设lambda项$M$的<strong>子项</strong>Multiset为${\rm Sub}(M)$</p><ol><li>（Basis）$\forall x \in V, {\rm Sub}(x)=\lbrace x\rbrace $</li><li>（应用）${\rm Sub}((M\ N))={\rm Sub}(M)\cup{\rm Sub}(N)\cup\lbrace (M\ N)\rbrace $</li><li>（抽象）${\rm Sub}((\lambda x.M))={\rm Sub}(M)\cup\lbrace \lambda x.M\rbrace $</li></ol><p>若$L \in {\rm Sub}(M)$，我们称$L$为$M$的子项.</p><p>子项关系有：</p><ol><li>（自反性）对所有lambda项$M$，有$M \in {\rm Sub}(M)$</li><li>（传递性）若$L \in {\rm Sub}(M)$且$M \in {\rm Sub}(N)$，则$L \in {\rm Sub}(N)$</li></ol><p>若将lambda项写成它的树形表示，我们可以直观的发现子项就是对应的子树.</p><p>若$L$是$M$的子项，且$L \not \equiv M$，称$L$是$M$的<strong>真子项</strong>（proper subterm）.</p><p>另外为了减少括号的使用，定义结合性和优先级：</p><ol><li>应用是左结合的，$M\ N\ L$为$(M(N\ L))$</li><li>应用的优先级比抽象高，$\lambda x.M\ N$为$\lambda x.(M\ N)$</li><li>连续的抽象$\lambda x.(\lambda y.M)$可以简写为，$\lambda xy.M$</li></ol><p>这些定义都与Haskell中的一致，所以挺符合直觉（？）</p><h2 id="自由和绑定变量"><a href="#自由和绑定变量" class="headerlink" title="自由和绑定变量"></a>自由和绑定变量</h2><p>lambda项中出现的变量可以分为三类：<strong>自由的</strong>（free）、<strong>被绑定的</strong>（bound）<strong>和绑定的</strong>（binding）.</p><p>其中，紧接着在$\lambda$后出现的，为绑定的变量；在项$\lambda x.M$中，$M$中的$x$即被绑定的变量；自由变量定义为：</p><p>设$FV$为一个lambda项中<strong>自由变量</strong>的集合，则</p><ol><li>（变量）$FV(x)=\lbrace x\rbrace $</li><li>（应用）$FV(M\ N)=FV(M)\cup FV(N)$</li><li>（抽象）$FV(\lambda x.M)=FV(M)-\lbrace x\rbrace $</li></ol><p>如果$FV(M)=\emptyset$，则称$M$为<strong>闭lambda项</strong>（Closed λ-term），也称<strong>组合子</strong>（combinator）. 所有闭lambda项的集合记为$\Lambda^0$.</p><h2 id="Alpha替换（Alpha-conversion）"><a href="#Alpha替换（Alpha-conversion）" class="headerlink" title="Alpha替换（Alpha conversion）"></a>Alpha替换（Alpha conversion）</h2><p>记$M^{x \rightarrow y}$为把$M$中所有自由变量$x$换成$y$.</p><ol><li><strong>重命名关系</strong>（renaming），符号为$=_\alpha$，定义为：$\lambda x.M =_\alpha \lambda y.M^{x \rightarrow y}$，其中满足$y \notin FV(M)$且$y$不是$M$中的binding变量.</li><li>若$M =_\alpha N$则$M\ L=_\alpha N\ L$，$L\ M=_\alpha L\ N$</li><li>有自反性、对称性、传递性. Alpha替换/重命名关系是一个等价关系.</li></ol><p>若$M =_\alpha N$，则称 $M$与$N$<strong>Alpha可替换</strong>（α-convertible）或<strong>Alpha等价</strong>（α-equivalent）. $M$为$N$的<strong>Alpha变形</strong>（α-variant）.</p><h2 id="代换（Substitution）"><a href="#代换（Substitution）" class="headerlink" title="代换（Substitution）"></a><strong>代换（Substitution）</strong></h2><p>将$M$中所有自由变量$x$ <strong>代换</strong>为$N$，记为$M[x:=N]$，定义为：</p><ol><li>a) $x[x:=N] \equiv N$  b) $y[x:=N] \equiv y$ ，若$x \not \equiv y$</li><li>$(PQ)[x:=N] \equiv (P[x:=N])(Q[x:=N])$</li><li>$(\lambda y.P)[x:=N] \equiv \lambda z.(P^{y \rightarrow z}[x:=N])$，若$\lambda z.P^{y \rightarrow z}$是$\lambda y.P$的Alpha变形，即$z \notin FV(N)$.</li></ol><p>注意含$[x:=N]$的项并不在lambda项的构造方法中，因此并不是lambda项，而是作为一种lambda项的“元表记”. 只有将所有$[x:=N]$全部消解了才能得到一个真的lambda项.</p><p>(1)就是对于$x$字面意义的代换. (2)普通地将替换推到应用的两边.</p><p>(3)的目的是为了防止变量名的冲突，如果$N$中有$y$的自由变量会被原本不应该的$(\lambda y.P)$的$y$绑定。因此需要引入一个不属于$N$的自由变量的$z$，替换原来的$y$. 如果$y \notin FV(N)$，则可以取$z \equiv y$，此时$(\lambda y.P[x:=N]) \equiv \lambda y.(P[x:=N])$.</p><p>引入<strong>顺序代换</strong>（sequential substitution），$M[x:=N][y:=L]$. </p><p><strong>引理：</strong></p><p>令$x \not \equiv y$，设$x \notin FV(L)$，则$M[x:=N][y:=L]\equiv M[y:=L][x:=N[y:=L]]$</p><h2 id="Lambda项模Alpha等价（Lambda-terms-modulo-α-equivalence）"><a href="#Lambda项模Alpha等价（Lambda-terms-modulo-α-equivalence）" class="headerlink" title="Lambda项模Alpha等价（Lambda-terms modulo α-equivalence）"></a><strong>Lambda项模Alpha等价（Lambda-terms modulo α-equivalence）</strong></h2><p><strong>引理：</strong></p><p>令$M_1 =_\alpha M_2$且$N_1 =_\alpha N_2$（？原文为$M_1=_\alpha N_1 \ and\  M_2 =_\alpha N_2 $），则：</p><ol><li>$M_1N_1 =_\alpha M_2N_2$</li><li>$\lambda x.M_1 =_\alpha \lambda x.M_2$</li><li>$M_1[x:=N_1] =_\alpha M_2[x:=N_2]$</li></ol><p>即lambda项构造上保持Alpha等价. 因此，我们将一个Alpha等价的等价类看作同一个抽象lambda项，将Alpha等价也视为相同，记$=_\alpha$为$\equiv$，称<strong>lambda项上模Alpha等价</strong>（λ-terms modulo α-equivalence）.</p><p><strong>Barendregt convention</strong>：我们选取绑定的变量时应使每个都不一样.</p><h2 id="Beta化简（Beta-reduction）"><a href="#Beta化简（Beta-reduction）" class="headerlink" title="Beta化简（Beta reduction）"></a>Beta化简（Beta reduction）</h2><p><strong>单步Beta化简</strong>（One-stepβ-reduction， $\rightarrow_\beta$）</p><ol><li>(Basis) $(\lambda x.M)N \rightarrow_\beta M[x:=N]$</li><li>(Compatibility)若$M \rightarrow_\beta N$，则$ML\rightarrow_\beta NL,LM\rightarrow_\beta LN$且$\lambda x.M \rightarrow_\beta \lambda x.N$</li></ol><p>其中左侧的称<strong>可化简式redex</strong>（reducible expression），右侧称（redex的）<strong>合同</strong>（contractum）.</p><p><strong>Beta化简</strong>（零步或多步，$\twoheadrightarrow_\beta$）</p><p>$M \twoheadrightarrow_\beta N$如果存在$n \geq 0$且存在项$M_0$到$M_n$使得$M_0 \equiv M,M_n \equiv N$，且任取$0 \leq i \lt n$有$M_i \rightarrow_\beta M_{i+1}$</p><p>即若$M \twoheadrightarrow_\beta N$，则存在一个从$M$开始到$N$的单步Beta化简的链：<br>$M \equiv M_0 \rightarrow_\beta M_1 \rightarrow_\beta M_2 \rightarrow_\beta … \rightarrow_\beta M_{n-1} \rightarrow_\beta M_n \equiv N $<br><strong>引理：</strong></p><ol><li>$\twoheadrightarrow_\beta$是$\rightarrow_\beta$的推广，若$M \rightarrow_\beta N$则$M \twoheadrightarrow_\beta N$</li><li>$\twoheadrightarrow_\beta$有自反性和传递性</li></ol><p>这个零步或多步的Beta化简的推广称为<strong>Beta替换</strong>（β-conversion），记作$=_\beta$.</p><p>$M =_\beta N$ </p><p>（读作“ $M与N$ <strong>Beta可替换</strong>（β-convertible）”或“<strong>Beta相等</strong>（β-equal）”）若存在$n \geq 0$且存在项$M_0$到$M_n$，使得$M_0 \equiv M,M_n \equiv N$且任取$0 \leq i \lt n$有$M_i \rightarrow_\beta M_{i+1}或M_{i+1} \rightarrow_\beta M_i$.</p><p>注意每一对$M_i$与$M_{i+1}$应该具有单步关系$\rightarrow_\beta$，但不一定要是从左到右的.</p><p> <strong>引理：</strong></p><ol><li>$=_\beta$是$\twoheadrightarrow_\beta$在两个方向上的推广，若$M \twoheadrightarrow_\beta N$或$N \twoheadrightarrow_\beta M$，则$M =_\beta N$</li><li>$=_\beta$是等价关系，有自反、对称、传递性</li></ol><h2 id="范式与汇合（Normal-forms-and-confluence）"><a href="#范式与汇合（Normal-forms-and-confluence）" class="headerlink" title="范式与汇合（Normal forms and confluence）"></a>范式与汇合（Normal forms and confluence）</h2><p><strong>Beta范式;可Beta标准化</strong>（β-normal form;β-nf;β-normalising）</p><ol><li>$M$是Beta范式，若$M$没有任何redex</li><li>$M$有Beta范式，或可Beta标准化，若存在$N$是Beta范式使得$M =_\beta N$. 这样的$N$称为$M$的Beta范式.</li></ol><p>一个lambda项的Beta范式可以看做它的输出（计算结果）.</p><p><strong>引理：</strong>当$M$是Beta范式，则$M \twoheadrightarrow_\beta N$蕴含$M \equiv N$.</p><p><strong>化简路径</strong>（Reduction path）</p><p>一个从$M$开始的<strong>有穷化简路径</strong>是一个项的有穷序列$N_0,N_1,…,N_n$，使得$N_0 \equiv M$且对任取$0 \leq i \lt n$有$N_i \rightarrow_\beta N_{i+1}$.</p><p>一个从$M$开始的<strong>无穷化简路径</strong>是一个项的无穷序列$N_0,N_1,…$，使得$N_0 \equiv M$且对任取$i \in \mathbb{N}$有$N_i \rightarrow_\beta N_{i+1}$.</p><p><strong>弱标准化，强标准化</strong>（Weak normalisation, strong normalisation）</p><ol><li>$M$可弱标准化，若存在Beta范式$N$使得$M \twoheadrightarrow_\beta N$.</li><li>$M$可强标准化，若不存在从$M$开始的无穷化简路径.</li></ol><p>如果$M$可强标准化，则任意化简路径都可以扩展到一个Beta范式为止；因此，可强标准化的也是可弱标准化.</p><p><strong>Church–Rosser定理;CR定理;汇合定理</strong>（Church–Rosser; CR; Confluence）</p><p>设对于lambda项$M$，有$M \twoheadrightarrow_\beta N_1$且$M \twoheadrightarrow_\beta N_2$，则存在lambda项$N_3$使得$N_1 \twoheadrightarrow_\beta N_3$且$N_2 \twoheadrightarrow_\beta N_3$.</p><p>这意味着一个演算结果（如果存在）与演算过程的顺序无关.</p><p><strong>推论：</strong>设$M =_\beta N$则存在$L$使得$M \twoheadrightarrow_\beta L$且$N \twoheadrightarrow_\beta L$.</p><ol><li>若$M$有Beta范式$N$，则$M \twoheadrightarrow_\beta N$</li><li>一个lambda项最多只有一个Beta范式</li></ol><h2 id="不动点定理（Fixed-Point-Theorem）"><a href="#不动点定理（Fixed-Point-Theorem）" class="headerlink" title="不动点定理（Fixed Point Theorem）"></a>不动点定理（Fixed Point Theorem）</h2><p><strong>定理：</strong> $\forall L \in \Lambda$存在$M \in \Lambda$使得$LM =_\beta M$.</p><p>证：取$M:=(\lambda x.L(xx))(\lambda x.L(xx))$，有<br>$$<br>M \equiv (\lambda x.L(xx))(\lambda x.L(xx)) \<br>\rightarrow_\beta L(,(\lambda x.L(xx))(\lambda x.L(xx)),) \<br>\equiv LM<br>$$</p><p>即$LM =_\beta M$.</p><p>我们定义<strong>不动点组合子</strong>（fixed point combinator）：</p><p>$Y \equiv \lambda y.(\lambda x.y(xx))(\lambda x.y(xx))$.</p><p>对于任意的lambda项$L$，都有$YL$是$L$的一个不动点，因为$L(YL)=_\beta YL$.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文为&lt;em&gt;Type Theory and Formal Proof : An Introduction&lt;/em&gt; 的笔记，纯个人向（&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;对于函数的抽象，有两个构造方法和一个计算规则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抽象（Abstraction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由一个表达式$M$和一个变量$x$ 可以构造表达式$\lambda x.M$，称为$M$上$x$的&lt;strong&gt;抽象（abstraction of x over M）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用（Application）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由表达式$M$和$N$可以构造表达式$M\ N$，称为$M$对$N$的&lt;strong&gt;应用（application of M to N）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Beta化简（β-reduction）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;形如$(\lambda x.M)N$的表达式可以被改写成$M[x:=N]$，意思是表达式中的$M$中的每个$x$换成$N$，这一过程称为由$(\lambda x.M)N$到$M[x:=N]$的&lt;strong&gt;Beta化简（β-reduction）&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;“应用”仅是构造另一个lambda项的过程，而真正得到结果的过程则是“Beta化简”.&lt;/p&gt;
&lt;p&gt;以下是严格定义&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="类型论" scheme="http://yoursite.com/tags/%E7%B1%BB%E5%9E%8B%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】二、单子</title>
    <link href="http://yoursite.com/2020/09/27/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91%E4%BA%8C%E3%80%81%E5%8D%95%E5%AD%90/"/>
    <id>http://yoursite.com/2020/09/27/【函数式】二、单子/</id>
    <published>2020-09-27T07:54:15.000Z</published>
    <updated>2020-09-27T08:24:43.640Z</updated>
    
    <content type="html"><![CDATA[<p>单子是Haskell语言中较难理解的概念，本文将以简明的语言介绍这一概念及其应用，由于通俗性与严谨性不可兼顾，本文会牺牲一定的严谨性（）。</p><h1 id="单子"><a href="#单子" class="headerlink" title="单子"></a>单子</h1><p><strong>Monad</strong>在Haskell中是一个类型类，中文通常翻译为<strong>单子</strong>，在GHC7.10以后它的定义如下：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Applicative</span> m =&gt; <span class="type">Monad</span> m <span class="keyword">where</span></span></span><br><span class="line">  (&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</span><br><span class="line">  (&gt;&gt;) :: m a -&gt; m b -&gt; m b</span><br><span class="line">  return :: a -&gt; m a</span><br><span class="line">  <span class="meta">&#123;-# MINIMAL (&gt;&gt;=) #-&#125;</span></span><br><span class="line">        <span class="comment">-- Defined in ‘GHC.Base’</span></span><br></pre></td></tr></table></figure><p>可以看出Monad是实现了一个<code>(&gt;&gt;=)</code>运算符的Applicative。而这个<code>(&gt;&gt;=)</code>运算符（<strong>Bind</strong>）类型古怪：它连接的左侧是一个Monad类型的值，右侧则是一个函数。</p><h1 id="Identity单子"><a href="#Identity单子" class="headerlink" title="Identity单子"></a>Identity单子</h1><p>我们从最基本的例子开始。</p><p>Identity单子定义在<code>Control.Monad.Identity</code>中：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">newtype</span> <span class="type">Identity</span> a = <span class="type">Identity</span> &#123;<span class="title">runIdentity</span> :: <span class="title">a</span>&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单子是Haskell语言中较难理解的概念，本文将以简明的语言介绍这一概念及其应用，由于通俗性与严谨性不可兼顾，本文会牺牲一定的严谨性（）。&lt;/p&gt;
&lt;h1 id=&quot;单子&quot;&gt;&lt;a href=&quot;#单子&quot; class=&quot;headerlink&quot; title=&quot;单子&quot;&gt;&lt;/a&gt;单子&lt;
      
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="Haskell" scheme="http://yoursite.com/tags/Haskell/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【函数式】一、函子</title>
    <link href="http://yoursite.com/2020/08/21/%E3%80%90%E5%87%BD%E6%95%B0%E5%BC%8F%E3%80%91%E4%B8%80%E3%80%81%E5%87%BD%E5%AD%90/"/>
    <id>http://yoursite.com/2020/08/21/【函数式】一、函子/</id>
    <published>2020-08-21T08:55:17.000Z</published>
    <updated>2020-08-22T16:05:30.094Z</updated>
    
    <content type="html"><![CDATA[<p>我们已经熟悉使用map函数对列表进行操作了：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]</span><br></pre></td></tr></table></figure><p>而函子就是对这一操作进行的抽象。Haskell通过类型类提供一些抽象的接口，将一些与类型相关的操作封装在了类型（对于类型类）的实现上。</p><a id="more"></a><h1 id="函子"><a href="#函子" class="headerlink" title="函子"></a>函子</h1><p>将map函数的功能进行抽象，发现map是将具有某种结构的数据应用一个函数，类似的我们可以定义对于树等其他数据结构的map。我们把具有这种性质的类型称为<strong>函子(Functor)</strong>，通常作为数据容器的类型都可以实现函子。</p><p>函子类型类在Haskell中如此定义：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span></span><br><span class="line">fmap :: (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>实现一个函子类型实现fmap函数。对比fmap和map的类型签名，可以发现fmap就是map函数的抽象。</p><p>列表也实现了函子类型类，对列表来说，fmap就是map：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> [] <span class="keyword">where</span></span></span><br><span class="line">fmap = map</span><br></pre></td></tr></table></figure><p>对于Maybe类型：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br><span class="line">fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)</span><br></pre></td></tr></table></figure><p>另外，还提供了一些运算符：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;$&gt;) = fmap</span><br><span class="line">(&lt;$) :: <span class="type">Functor</span> f =&gt; a -&gt; f b -&gt; f a</span><br><span class="line">(&lt;$) = fmap.const</span><br></pre></td></tr></table></figure><p>其中&lt;\$&gt;就是fmap的中缀版本，&lt;\$少见，是fmap.const：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">"1"</span> &lt;$ [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="string">"1"</span>,<span class="string">"1"</span>,<span class="string">"1"</span>]</span><br><span class="line">&gt; <span class="string">"1"</span> &lt;$ <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="string">"1"</span></span><br></pre></td></tr></table></figure><h2 id="Functor定律"><a href="#Functor定律" class="headerlink" title="Functor定律"></a>Functor定律</h2><p>并不是只要实现了fmap的类型就是函子，函子的fmap函数应当满足一些性质保证使用时的正确性：<br>$$<br>fmap\ id=id<br>$$<br>$$<br>fmap\ (f\circ g)= fmap\ f\circ fmap\ g<br>$$<br>第一条定律说明fmap应该保持该类型的结构，除了应用函数外不应有其他的操作。第二条说明fmap对于函数复合运算应满足分配律。</p><h1 id="可应用函子"><a href="#可应用函子" class="headerlink" title="可应用函子"></a>可应用函子</h1><p>当函子中的是函数时，显然是无法直接应用的，此时就需要实现<strong>可应用函子(Applicative Functor)</strong>。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span></span><br><span class="line">pure :: a -&gt; f a</span><br><span class="line">(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>pure函数将一个a类型的值变为一个可应用函子类型f a的值，而&lt;*&gt;函数可以将函子里的函数应用于函子里的值。</p><p>与函数应用操作符\$对比，&lt;*&gt;是在对应的函子类型范围应用函数，而&lt;\$&gt;则是直接将函数应用于函子。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">($) :: (a -&gt; b) -&gt; a -&gt; b</span><br><span class="line">(&lt;$&gt;) :: <span class="type">Functor</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line">(&lt;*&gt;) :: <span class="type">Applicative</span> f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</span><br></pre></td></tr></table></figure><p>对于Maybe类型，可以这么实现Applicative：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span></span><br><span class="line">pure = <span class="type">Just</span></span><br><span class="line"><span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span></span><br><span class="line">(<span class="type">Just</span> f) &lt;*&gt; arg = fmap f arg</span><br></pre></td></tr></table></figure><p>Nothing是&lt;*&gt;运算的零元；而对于Just f，则取出函数f，使用fmap函数将它应用于函子。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Just</span> (+ <span class="number">1</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="number">2</span></span><br><span class="line">&gt; <span class="type">Nothing</span> &lt;*&gt; <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line">&gt; <span class="type">Just</span> (+ <span class="number">1</span>) &lt;*&gt; <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span></span><br></pre></td></tr></table></figure><p>而在Control.Applicative提供了函数将a -&gt; b的函数抬升为f a -&gt; f b</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">liftA</span> :: <span class="type">Applicative</span> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</span><br><span class="line"><span class="title">liftA</span> f a = pure f &lt;*&gt; a</span><br><span class="line"><span class="title">liftA2</span> :: <span class="type">Applicative</span> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</span><br><span class="line"><span class="title">liftA2</span> f a b = f &lt;$&gt; a &lt;*&gt; b</span><br></pre></td></tr></table></figure><p>liftA用于一元函数（和fmap没啥区别？），liftA2用于二元函数。</p><p>另外还有两个运算符：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(*&gt;) :: f a -&gt; f b -&gt; f b</span><br><span class="line"><span class="title">u</span> *&gt; v = pure (const id) &lt;*&gt; u &lt;*&gt; v</span><br><span class="line">(&lt;*) :: f a -&gt; f b -&gt; f a</span><br><span class="line"><span class="title">u</span> &lt;* v = pure const &lt;*&gt; u &lt;*&gt; v</span><br></pre></td></tr></table></figure><p>与&lt;\$类似，&lt;*返回前一项，而*&gt;返回后一项</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="type">Nothing</span> &lt;* <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Nothing</span></span><br><span class="line">&gt; <span class="type">Nothing</span> *&gt; <span class="type">Just</span> <span class="number">1</span></span><br><span class="line"><span class="type">Just</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>列表也实现了Applicative，效果类似于list comprehension</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> [] <span class="keyword">where</span></span></span><br><span class="line">pure x = [x]</span><br><span class="line">fs &lt;*&gt; xs = [f x | f &lt;- fs, x &lt;- xs]</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [(+ <span class="number">1</span>),(* <span class="number">2</span>)] &lt;*&gt; [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们已经熟悉使用map函数对列表进行操作了：&lt;/p&gt;
&lt;figure class=&quot;highlight haskell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;title&quot;&gt;map&lt;/span&gt; :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;而函子就是对这一操作进行的抽象。Haskell通过类型类提供一些抽象的接口，将一些与类型相关的操作封装在了类型（对于类型类）的实现上。&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="函数式" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F/"/>
    
      <category term="Haskell" scheme="http://yoursite.com/tags/Haskell/"/>
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>【杂记】SICP学习笔记（序）</title>
    <link href="http://yoursite.com/2019/12/06/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91SICP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/06/【杂记】SICP学习笔记（序）/</id>
    <published>2019-12-06T10:15:33.000Z</published>
    <updated>2020-06-23T09:28:36.021Z</updated>
    
    <content type="html"><![CDATA[<p>大一上学期结束了，给我最大震撼的还是这门SICP课；由于过于震撼，我觉得有必要记录下来。原本打算学期结束后写一系列文章总结一下，不料下学期课业过于刺激，只好草草以一篇“序”结束。不过虽然课程结束了，学习仍要继续，所以学习笔记也会不断延伸（？）</p><a id="more"></a><p>说来惭愧，这学期初选课的时候，才第一次听说SICP课，后来到了正式上课，才渐渐了解。这是门名叫“计算机程序的构造和解释”的课程（Structure and Interpretation of Computer Programs/SICP），原书是MIT的著名教程，原课程是UC Berkeley的著名“网红课程”cs61a。这还是我们学校第一次引进这门课程，基本上就是使用的就是cs61a的教程，使用python作为主要的教学语言（然而秉着大一上保护萌新的原则，还是对其内容有一些删减，尽管如此，这也已经让我大开眼界）。</p><p>先看看这一学期都教了些什么吧：</p><ul><li>python语言</li><li>FP部分（递归、副作用、高阶函数、lambda演算）</li><li>数据抽象（用函数闭包实现的树）</li><li>OOP部分（用class重新实现数据抽象）</li><li>scheme语言</li><li>解释器原理</li><li>SQL语言</li><li>……</li></ul><p>这门课的进度我是从开学震撼到结束——实在是太快了、内容太丰富了（然而即使如此，仍然比Berkeley的进度还差一大截）。照我之前的印象中，CS系入门课永远是命令式语言的，后面过渡到OOP，像FP似乎都属于先进技术了，编译原理则更是忌讳给新手打开的黑箱、魔盒……然而，我仍然做到了，完成了上面的所有内容，学到最后的同学们都做到了（确实一开课就劝退了很多“萌新”、堪称退课率最高的一门了……）。这显然是cs61a这课程设计的功劳。</p><h1 id="CS61a"><a href="#CS61a" class="headerlink" title="CS61a"></a>CS61a</h1><p>我已经吹过无数遍cs61a，因为它实在是太精致了。每一个部分显然都是经过精心设计的：  </p><h2 id="一、课程结构"><a href="#一、课程结构" class="headerlink" title="一、课程结构"></a>一、课程结构</h2><p>课程分普通上课（Lecture）、上机实验课（Lab），作业分平时作业（Homework）和大作业（Project）。<br>有一说一，就作业的量来看，这个强度已经远远大于大一CS的传统基础课程“程序设计基础了（说是C++，不如说就是C编程）”。<br>Homework是一周一次，量不大，是与课时内容一致的练习题。值得一提的是，每次homework，都留一些附加题；这些附加题就很有深度了（似乎是课时不够塞不进，但教师真的很想传递的内容（小声））：像“匿名阶乘”（只用lambda，不递归实现阶乘，方法是不动点算子，，，）、“church numeral”（相当于让你自己发明一遍church numeral（orz））……非常震撼，都是想都不敢想会在大一接触到的内容……  </p><p>重头戏是Project,感觉真的是课程设计者的心血所在了。我们这学期做了四个project，分别是：The Game of Hog（一个掷骰子游戏）、Autocorrected Typing Software（打字软件）、Ants Vs. SomeBees（Plants Vs. Zombies复刻，，，）和Scheme Interpreter（Scheme语言的解释器！！！）<br>纯萌新、一学期、整这四个大活儿……<br>当然不是从零写起……学生只负责完成核心算法（当中的几行）的实现（<br>我想到的一个绝佳的比喻就是IKEA的家具，，，它已经为你实现了绝大多数的工作，却硬是要你去把它自己动手安装成一个能用的家具。然而，尽管只剩下一些最微小的工作，你还是不会组装这些部件。于是，它还提供了一份非常详尽的说明书，真的手把手地教你拼成。就是看说明书、一步步地拼的过程中，竟也理解了这个家具的内部结构。而最后，你得到一个能够使用的家具，还是自己动手做成的，属实很有成就感。  </p><p>回到cs61a的project，这些程序最困难的架构、UI、测试板块都已经完全提供了。另外，还附带说明书一份，整个做project的过程就是看着说明书一步步拼家具的过程。<br>之前总看到有人问：学C/C++这么长时间，为什么都只是“黑框程序”？为什么和看到的软件差别那么大？学这编程到底是做什么的？难道就是解数学题？<br>这些疑问，我肯定大部分按国内“科班编程教育”学下来的都有过。没办法，大一打基础，C++是基本功嘛。我也深知要一上来就搞图形界面显然不现实的。然而，cs61a懂学生的顾虑，在第一时间就传递给学生：编程是魔法，自己动手，什么都能创造。</p><p>不光如此，project还提供给学生<strong>阅读代码</strong>的机会，尤其是<strong>阅读优质代码</strong>的机会。这个就太难得了。据我所知，基础课“程序设计基础”就没有时间深入对代码规范的讲解——确实，比起数据类型、指针，那些“基本功”，代码风格显得不那么重要；而且，对于初学的那些几十行的小程序，也无法让学生理解为什么需要代码的规范；甚至，在上机时，为了高效a题，有种向OI/竞赛码风靠拢的倾向。<br>即使是OI时，阅读代码的唯一机会也就是那初赛码风奇异的阅读程序题……我还记得在我第一次看到DirectX的代码时有多震撼……<br>然而，cs61a的project就提供了这种“大项目”的语境，project提供的代码显然都是非常规范的，不论是命名风格还是写法，注释的量超过了有效代码。学生完成project，在填入代码前，首先要阅读；这样，就已经是“见识过好代码”的人了。</p><p>另外，project的选题也很合学生胃口啊。像讲到OOP时，就出了复刻PVZ的project，游戏物体都是一个基类派生，各种植物就是需要学生完成的各种派生类……现在，回想一下国内教科书的OOP习题……嗯，学生管理系统，，，嗯老师同学都是人，大一大二都是学生，，，   </p><h2 id="二、课程设计"><a href="#二、课程设计" class="headerlink" title="二、课程设计"></a>二、课程设计</h2><p>以下内容均为本人学习该课程后的主观推断（</p><h3 id="为什么选择python"><a href="#为什么选择python" class="headerlink" title="为什么选择python"></a>为什么选择python</h3><p>一个问题就是为什么用python作为教学语言。毕竟，对CS学生来说，一上手就python的话，一些特性可能会养成不好的习惯……（之类的吧）<br>但就这门课来说，选择python十分合理。  </p><p>首先，python是多范式的。上面提到的课程内容中，命令式的、FP、OOP都要学习，所以显然需要选择一门能够覆盖这些范式的语言。另外，python的动态解释特性（个人以为也给课程造成了一些麻烦……）使它对FP的支持比C++好了不少。  </p><p>其次，python是解释执行的，支持交互式编程。为什么这点这么重要？为了课程中最吸引人的一部分：要实现一个scheme解释器。学习python，也就理解了解释的大概过程、什么是REPL。更重要的是，scheme的许多语法与python是一一对应的，这减少了完成解释器很大的一部分工作量。做完解释器，似乎只是完成了parsing，翻译成python的数据，直接就出来了。</p><h3 id="为什么选择scheme"><a href="#为什么选择scheme" class="headerlink" title="为什么选择scheme"></a>为什么选择scheme</h3><p>可能，主要原因是语法结构简单，都是前缀的表达式，便于写解释器……另外，scheme的FP也与之前所学相契合，解释的特性也与python一致，是水到渠成：scheme竟一节课学完就可以无痛感的熟练编程了，可见其课程设计的环环相扣。而，scheme的范式也与python不同，便于将两门语言对比学习。</p><h3 id="为什么内容这么多"><a href="#为什么内容这么多" class="headerlink" title="为什么内容这么多"></a>为什么内容这么多</h3><p>我的解释是目标不一样。以“程序设计基础”为代表的国内“科班编程教育”的入门课，目的就是“打好基本功”，我认为是有道理的。CS学习计算机科学，C++是最好的材料了，正如学习音乐，钢琴是最好的材料一样。但这样“埋头走路”的方式，常常会使一些（估计是大部分）学生晕头转向，不知道在学些什么，有什么意义。就像我的导师所说，他教授的编译原理课程，有很多同学一个学期下来，都不知道学的有什么用处。<br>而同样是作为入门课的SICP，目的却是“抬头看路”。有一说一，这样的高强度“走马观花”下来，“码力”也许确实会欠缺一些，但视野却已经大不一样了：见识到的是计算机程序设计的“蓝图”——编程是什么？程序是什么？什么是编程语言？什么是编程范式？函数式的、面向对象的，命令式的、声明式的，解决什么样的问题？什么是抽象？编程能干什么？以后还要学什么？……<br>这样一来，学习热情就可想而知。</p><h2 id="三"><a href="#三" class="headerlink" title="三"></a>三</h2><p>这里还不得不提一下我们的老师，冯新宇教授。据他讲也是“临危受命”，作为编程语言方面的专家，来开这门新课。随着课程的推进，就发现和这门课的相性真的很好（逃）。毕竟要把这门内容如此丰富的课程讲明白也非易事，尤其是到编程语言的对比、特性的设计方面，编译过程的解释方面的讲解，都让我大开眼界、受益匪浅。我课下也与老师对于程序语言特性设计方面的疑惑进行了许多探讨，老师的解答都让我醍醐灌顶，使我敬仰万分……在最后一节课，老师还夹带了些“私货”，介绍了了一门更为奇异的coq语言，讲解了证明过程，还介绍了计算机程序的形式验证方法，令我叹为观止……增加了我学习Haskell的动力（？）</p><p>接下来的学习笔记，再整理SICP这门课中学到的mind-blowing的事吧（咕咕咕）。如果有空，可能还有对冯佬Q&amp;A的番外……</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大一上学期结束了，给我最大震撼的还是这门SICP课；由于过于震撼，我觉得有必要记录下来。原本打算学期结束后写一系列文章总结一下，不料下学期课业过于刺激，只好草草以一篇“序”结束。不过虽然课程结束了，学习仍要继续，所以学习笔记也会不断延伸（？）&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【Fr2D开发笔记】四、图形、位图和文本渲染</title>
    <link href="http://yoursite.com/2019/08/04/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/04/【杂记】Fr2D开发笔记（四）/</id>
    <published>2019-08-04T04:02:13.000Z</published>
    <updated>2020-07-02T13:27:02.199Z</updated>
    
    <content type="html"><![CDATA[<p>初始化了Direct2D之后，就可以开始绘制了。</p><a id="more"></a><h1 id="一、几何图元"><a href="#一、几何图元" class="headerlink" title="一、几何图元"></a>一、几何图元</h1><p>如上篇所示，绘制几何图形的方法都在RenderTarget对象中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    D2D1_POINT_2F point0,</span></span></span><br><span class="line"><span class="function"><span class="params">    D2D1_POINT_2F point1,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in] ID2D1Brush *brush,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT strokeWidth = <span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in, optional] ID2D1StrokeStyle *strokeStyle = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawRectangle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    [ref] <span class="keyword">const</span> D2D1_RECT_F &amp;rect,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in] ID2D1Brush *brush,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT strokeWidth =<span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in, optional] ID2D1StrokeStyle *strokeStyle = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    [ref] <span class="keyword">const</span> D2D1_ELLIPSE &amp;ellipse,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in] ID2D1Brush *brush,</span></span></span><br><span class="line"><span class="function"><span class="params">    FLOAT strokeWidth =<span class="number">1.0f</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    [in, optional] ID2D1StrokeStyle *strokeStyle = <span class="literal">NULL</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>等。</p><p>其中，D2D提供结构体表示对应的图元，可以使用D2D1中的对应函数构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2D_RECT_F</span> &#123;</span></span><br><span class="line">    FLOAT left;</span><br><span class="line">    FLOAT top;</span><br><span class="line">    FLOAT right;</span><br><span class="line">    FLOAT bottom;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2D1_ELLIPSE</span> &#123;</span></span><br><span class="line">    D2D1_POINT_2F point;</span><br><span class="line">    FLOAT radiusX;</span><br><span class="line">    FLOAT radiusY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">D2D1_RECT_F <span class="title">RectF</span><span class="params">(FLOAT left = <span class="number">0.f</span>, FLOAT top = <span class="number">0.f</span>, FLOAT right = <span class="number">0.f</span>, FLOAT bottom = <span class="number">0.f</span>)</span></span>;</span><br><span class="line"><span class="function">D2D1_ELLIPSE <span class="title">Ellipse</span><span class="params">(<span class="keyword">const</span> D2D1_POINT_2F &amp;center, FLOAT radiusX, FLOAT radiusY)</span></span>;</span><br></pre></td></tr></table></figure><p>如此，可将一些图形的绘制函数封装在Fr2D类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fr2D</span> &#123;</span><span class="comment">//as a d2d render target</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawLine</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawRectangle</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FillRectangle</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawEllipse</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FillEllipse</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DrawTriangle</span><span class="params">(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, <span class="keyword">float</span> x3, <span class="keyword">float</span> y3, <span class="keyword">float</span> width)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HWND * hwndptr;</span><br><span class="line">ID2D1Factory * d2dFactory;</span><br><span class="line">ID2D1HwndRenderTarget* hdl;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawLine(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(left, top), D2D1::Point2F(right, bottom), fr2dbrush.GetBrush(), width);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawRectangle(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawRectangle(</span><br><span class="line">D2D1::RectF(left, top, right, bottom),</span><br><span class="line">fr2dbrush.GetBrush(),</span><br><span class="line">width</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::FillRectangle(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">hdl-&gt;FillRectangle(</span><br><span class="line">D2D1::RectF(left, top, right, bottom),</span><br><span class="line">fr2dbrush.GetBrush()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawEllipse(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawEllipse(</span><br><span class="line">D2D1::Ellipse(&#123; (left + right) / <span class="number">2</span>,(top + bottom) / <span class="number">2</span> &#125;, (right - left) / <span class="number">2</span>, (bottom - top) / <span class="number">2</span>),</span><br><span class="line">fr2dbrush.GetBrush(),</span><br><span class="line">width</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::FillEllipse(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">hdl-&gt;FillEllipse(</span><br><span class="line">D2D1::Ellipse(&#123; (left + right) / <span class="number">2</span>,(top + bottom) / <span class="number">2</span> &#125;, (right - left) / <span class="number">2</span>, (bottom - top) / <span class="number">2</span>),</span><br><span class="line">fr2dbrush.GetBrush()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> Fr2D::DrawTriangle(Fr2DBrush &amp;fr2dbrush, <span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2, <span class="keyword">float</span> x3, <span class="keyword">float</span> y3, <span class="keyword">float</span> width) &#123;</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(x1, y1), D2D1::Point2F(x2, y2), fr2dbrush.GetBrush(), width);</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(x2, y2), D2D1::Point2F(x3, y3), fr2dbrush.GetBrush(), width);</span><br><span class="line">hdl-&gt;DrawLine(D2D1::Point2F(x3, y3), D2D1::Point2F(x1, y1), fr2dbrush.GetBrush(), width);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即可使用Fr2D对象和Fr2DBrush对象绘制对应图形。</p><h1 id="二、位图"><a href="#二、位图" class="headerlink" title="二、位图"></a>二、位图</h1><p>Direct2D的位图是基于WIC（Windows Image Component）来完成的，是基于COM组件的技术。WIC组件可以支持大部分图像格式的解码。</p><h2 id="创建WIC位图"><a href="#创建WIC位图" class="headerlink" title="创建WIC位图"></a>创建WIC位图</h2><p>将WIC位图的创建封装至FrBitmap类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> FrBitmap::Create() &#123;</span><br><span class="line">    ID2D1Bitmap * pBitmap;</span><br><span class="line">IWICImagingFactory *pIWICFactory;</span><br><span class="line">IWICBitmapDecoder *pDecoder;</span><br><span class="line">IWICBitmapFrameDecode *pSource;</span><br><span class="line">IWICStream *pStream;</span><br><span class="line">IWICFormatConverter *pConverter;</span><br><span class="line">IWICBitmapScaler *pScaler;</span><br><span class="line">    </span><br><span class="line">HRESULT hr = S_OK;</span><br><span class="line">pIWICFactory = <span class="literal">NULL</span>;</span><br><span class="line">pDecoder = <span class="literal">NULL</span>;</span><br><span class="line">pSource = <span class="literal">NULL</span>;</span><br><span class="line">pStream = <span class="literal">NULL</span>;</span><br><span class="line">pConverter = <span class="literal">NULL</span>;</span><br><span class="line">pScaler = <span class="literal">NULL</span>;</span><br><span class="line">hr = CoInitializeEx(<span class="literal">NULL</span>, COINIT_MULTITHREADED);</span><br><span class="line">hr = CoCreateInstance(</span><br><span class="line">CLSID_WICImagingFactory,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">CLSCTX_INPROC_SERVER,</span><br><span class="line">IID_IWICImagingFactory,</span><br><span class="line">(LPVOID*)&amp;pIWICFactory</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">hr = pIWICFactory-&gt;CreateDecoderFromFilename(</span><br><span class="line">picname.c_str(),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">GENERIC_READ,</span><br><span class="line">WICDecodeMetadataCacheOnLoad,</span><br><span class="line">&amp;pDecoder</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Create the initial frame.</span></span><br><span class="line">hr = pDecoder-&gt;GetFrame(<span class="number">0</span>, &amp;pSource);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 1failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">&#123;</span><br><span class="line">hr = pIWICFactory-&gt;CreateFormatConverter(&amp;pConverter);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 2failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr = pConverter-&gt;Initialize(</span><br><span class="line">pSource,</span><br><span class="line">GUID_WICPixelFormat32bppPBGRA,</span><br><span class="line">WICBitmapDitherTypeNone,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="number">0.f</span>,</span><br><span class="line">WICBitmapPaletteTypeMedianCut</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 3failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处注意对多线程程序，创建时须使用参数CoInitializeEx(NULL, COINIT_MULTITHREADED);</p><h2 id="Direct2D位图"><a href="#Direct2D位图" class="headerlink" title="Direct2D位图"></a>Direct2D位图</h2><p>TODO：此处的接口设计不科学，后应改成友元类实现。</p><p>创建WIC位图后就可以创建Direct2D位图了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> Fr2D::CreateBitmap(FrBitmap &amp;bmp) &#123;</span><br><span class="line">HRESULT hr;</span><br><span class="line">hr = hdl-&gt;CreateBitmapFromWicBitmap(</span><br><span class="line">bmp.GetConverter(),</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">bmp.GetBitmapPtr()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw 4failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">bmp.Release();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的Release函数是释放使用的COM组件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SAFE_RELEASE(P) <span class="meta-keyword">if</span>(P)&#123;P-&gt;Release() ; P = NULL ;&#125;</span></span><br><span class="line"><span class="keyword">void</span> FrBitmap::Release() &#123;</span><br><span class="line">SAFE_RELEASE(pDecoder);</span><br><span class="line">SAFE_RELEASE(pSource);</span><br><span class="line">SAFE_RELEASE(pStream);</span><br><span class="line">SAFE_RELEASE(pConverter);</span><br><span class="line">SAFE_RELEASE(pScaler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制位图"><a href="#绘制位图" class="headerlink" title="绘制位图"></a>绘制位图</h2><p>全部创建完毕，就可以绘图了，绘制方法在RenderTarget中：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Fr2D::DrawBitmap(FrBitmap &amp;bmp, <span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">hdl-&gt;DrawBitmap(</span><br><span class="line">bmp.GetBitmap(),</span><br><span class="line">D2D1::RectF(left, top, right, bottom)</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、文本"><a href="#三、文本" class="headerlink" title="三、文本"></a>三、文本</h1><p>在Direct2D中，文本的绘制是通过DirectWrite来实现的，需要头文件Dwrite.h和静态库dwrite.lib。</p><h2 id="初始化Dwrite"><a href="#初始化Dwrite" class="headerlink" title="初始化Dwrite"></a>初始化Dwrite</h2><p>Dwrite这块初始化是与Direct2D的Factory类无关的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrText</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(<span class="keyword">float</span> left = <span class="number">0.f</span>, <span class="keyword">float</span> top = <span class="number">0.f</span>, <span class="keyword">float</span> right = <span class="number">200.f</span>, <span class="keyword">float</span> bottom = <span class="number">200.f</span>)</span></span>;</span><br><span class="line"><span class="function">IDWriteTextFormat* <span class="title">GetFormat</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetRect</span><span class="params">(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom)</span></span>;</span><br><span class="line"></span><br><span class="line">D2D1_RECT_F layoutRect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">IDWriteFactory * pDWriteFactory;</span><br><span class="line">IDWriteTextFormat* pTextFormat;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FrText::Create(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">DWriteCreateFactory(</span><br><span class="line">DWRITE_FACTORY_TYPE_SHARED,</span><br><span class="line">__uuidof(IDWriteFactory),</span><br><span class="line"><span class="keyword">reinterpret_cast</span>&lt;IUnknown**&gt;(&amp;pDWriteFactory));</span><br><span class="line"></span><br><span class="line">HRESULT hr = pDWriteFactory-&gt;CreateTextFormat(</span><br><span class="line"><span class="string">L"Arial"</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">DWRITE_FONT_WEIGHT_NORMAL,</span><br><span class="line">DWRITE_FONT_STYLE_NORMAL,</span><br><span class="line">DWRITE_FONT_STRETCH_NORMAL,</span><br><span class="line"><span class="number">20.0f</span> * <span class="number">96.0f</span> / <span class="number">72.0f</span>,</span><br><span class="line"><span class="string">L"en-US"</span>,</span><br><span class="line">&amp;pTextFormat</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">layoutRect = D2D1::RectF(left, top, right, bottom);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IDWriteTextFormat* FrText::GetFormat() &#123;</span><br><span class="line"><span class="keyword">return</span> pTextFormat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> FrText::SetRect(<span class="keyword">float</span> left, <span class="keyword">float</span> top, <span class="keyword">float</span> right, <span class="keyword">float</span> bottom) &#123;</span><br><span class="line">layoutRect.left = left;</span><br><span class="line">layoutRect.top = top;</span><br><span class="line">layoutRect.right = right;</span><br><span class="line">layoutRect.bottom = bottom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Fr2D::Write(FrText &amp;frText, Fr2DBrush &amp;fr2dBrush, <span class="built_in">std</span>::<span class="built_in">string</span> s) &#123;</span><br><span class="line">hdl-&gt;DrawText(</span><br><span class="line">stringToLPCWSTR(s),</span><br><span class="line">s.length(),</span><br><span class="line">frText.GetFormat(),</span><br><span class="line">frText.layoutRect,</span><br><span class="line">fr2dBrush.GetBrush()</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初始化了Direct2D之后，就可以开始绘制了。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Fr2D开发笔记" scheme="http://yoursite.com/tags/Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图形学" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="DirectX" scheme="http://yoursite.com/tags/DirectX/"/>
    
  </entry>
  
  <entry>
    <title>【Fr2D开发笔记】三、Direct2D初始化</title>
    <link href="http://yoursite.com/2019/08/03/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/03/【杂记】Fr2D开发笔记（三）/</id>
    <published>2019-08-03T13:25:21.000Z</published>
    <updated>2020-07-02T10:18:09.611Z</updated>
    
    <content type="html"><![CDATA[<p>创建好一个窗体后，就可以使用Direct2D绘制了。</p><p>Direct2D程序需要包含头文件d2d1.h，和静态库d2d1.lib。这里简单介绍一下Direct2D程序初始化过程。</p><a id="more"></a><h1 id="一、ID2D1Factory"><a href="#一、ID2D1Factory" class="headerlink" title="一、ID2D1Factory"></a>一、ID2D1Factory</h1><p>首先是ID2D1Factory类，是Direct2D其他对象的工厂类，需要首先创建。使用D2D1CreateFactory函数构造，第一个参数是程序线程类型。正常创建返回S_OK，否则返回的HRESULT包含错误信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ID2D1Factory * d2dFactory;</span><br><span class="line">HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &amp;d2dFactory);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">    MessageBox(hwnd, _T(<span class="string">"Create D2D factory failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二、RenderTarget"><a href="#二、RenderTarget" class="headerlink" title="二、RenderTarget"></a>二、RenderTarget</h1><p>Direct2D的渲染都在渲染目标（？）对象中进行，创建工厂类对象后就可以使用它创建一个RenderTarget。</p><p>Direct2D提供多种RenderTarget，这里使用窗口句柄渲染目标ID2D1HwndRenderTarget可以实现在目标窗口上的渲染。</p><p>使用ID2D1Factory对象的成员函数CreateHwndRenderTarget构造，第一个参数可以通过D2D1::RenderTargetProperties函数获得，第二个参数通过D2D1::HwndRenderTargetProperties获得，提供窗口句柄和大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ID2D1HwndRenderTarget* hdl;</span><br><span class="line">RECT rc;</span><br><span class="line">GetClientRect(hwnd, &amp;rc);</span><br><span class="line">HRESULT hr = d2dFactory-&gt;CreateHwndRenderTarget(</span><br><span class="line">    D2D1::RenderTargetProperties(),</span><br><span class="line">    D2D1::HwndRenderTargetProperties(</span><br><span class="line">        hwnd,</span><br><span class="line">        D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)</span><br><span class="line">    ),</span><br><span class="line">    &amp;hdl</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">    MessageBox(hwnd, _T(<span class="string">"Create render target failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、固体颜色刷"><a href="#三、固体颜色刷" class="headerlink" title="三、固体颜色刷"></a>三、固体颜色刷</h1><p>固体颜色画刷ID2D1SolidColorBrush是由渲染目标对象的成员函数CreateSolidColorBrush创建的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ID2D1SolidColorBrush* brush;</span><br><span class="line">hr = hdl-&gt;CreateSolidColorBrush(</span><br><span class="line">    D2D1::ColorF(D2D1::ColorF::Red),</span><br><span class="line">    &amp;brush</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create brush failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="四、开始画图"><a href="#四、开始画图" class="headerlink" title="四、开始画图"></a>四、开始画图</h1><p>现在，可以开始画图了。</p><p>调用渲染目标对象的成员函数BeginDraw开始绘图，Clear函数用某一颜色清屏；我们使用DrawRectangle函数用笔刷绘制一个矩形，最后调用EndDraw函数结束绘图。Direct2D的屏幕坐标以左上角为原点，x轴向右，y轴向下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">hdl-&gt;BeginDraw();</span><br><span class="line">hdl-&gt;Clear(D2D1::ColorF(D2D1::ColorF::White));</span><br><span class="line">hdl-&gt;DrawRectangle(</span><br><span class="line">    D2D1::RectF(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">    brush</span><br><span class="line">);</span><br><span class="line">HRESULT hr = hdl-&gt;EndDraw();</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面展示的就是Direct2D绘图的HelloWorld程序了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"frwnd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"d2d1.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWND hwnd;</span><br><span class="line">ID2D1Factory * d2dFactory;</span><br><span class="line">ID2D1HwndRenderTarget* hdl;</span><br><span class="line">ID2D1SolidColorBrush* brush;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HRESULT hr = D2D1CreateFactory(D2D1_FACTORY_TYPE_SINGLE_THREADED, &amp;d2dFactory);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create D2D factory failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RECT rc;</span><br><span class="line">GetClientRect(hwnd, &amp;rc);</span><br><span class="line">hr = d2dFactory-&gt;CreateHwndRenderTarget(</span><br><span class="line">D2D1::RenderTargetProperties(),</span><br><span class="line">D2D1::HwndRenderTargetProperties(</span><br><span class="line">hwnd,</span><br><span class="line">D2D1::SizeU(rc.right - rc.left, rc.bottom - rc.top)</span><br><span class="line">),</span><br><span class="line">&amp;hdl</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create render target failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hr = hdl-&gt;CreateSolidColorBrush(</span><br><span class="line">D2D1::ColorF(D2D1::ColorF::Red),</span><br><span class="line">&amp;brush</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(hwnd, _T(<span class="string">"Create brush failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">hdl-&gt;BeginDraw();</span><br><span class="line">hdl-&gt;Clear(D2D1::ColorF(D2D1::ColorF::White));</span><br><span class="line">hdl-&gt;DrawRectangle(</span><br><span class="line">D2D1::RectF(<span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>),</span><br><span class="line">brush</span><br><span class="line">);</span><br><span class="line">HRESULT hr = hdl-&gt;EndDraw();</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, _T(<span class="string">"Draw failed!"</span>), _T(<span class="string">"Error"</span>), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FrWnd <span class="title">myWnd</span><span class="params">(<span class="number">640</span>, <span class="number">480</span>, WndProc, Display, <span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(WINPARAMETERS)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!myWnd.Create(INITPARAMETERS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">hwnd = myWnd.GetHandle();</span><br><span class="line">Init();</span><br><span class="line">myWnd.Run();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>画出来了：</p><p><a href="https://www.z4a.net/image/TnRpLI" target="_blank" rel="noopener"><img src="https://www.z4a.net/images/2020/06/28/fr2dhelloworld.png" alt="fr2dhelloworld.png"></a></p><h1 id="五、封装初始化过程"><a href="#五、封装初始化过程" class="headerlink" title="五、封装初始化过程"></a>五、封装初始化过程</h1><p>Fr2D封装Direct2D的初始化过程。将工厂类ID2D1Factory和ID2D1HwndRenderTarget封装到Fr2D类，是Fr2D的工厂类，完成对Fr2D中其他对象的创建；ID2D1SolidColorBrush封装为Fr2DBrush。如此，上面的HelloWorld程序就变成了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"frwnd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"fr2d.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWND hwnd;</span><br><span class="line"><span class="function">Fr2D <span class="title">fr2d</span><span class="params">(hwnd)</span></span>;</span><br><span class="line">Fr2DBrush redBrush;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fr2d.Create();</span><br><span class="line">fr2d.CreateBrush(redBrush, _FR2DCOLOR(Red));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">fr2d.BeginDraw();</span><br><span class="line">fr2d.Clear(_FR2DCOLOR(White));</span><br><span class="line">fr2d.DrawRectangle(redBrush, <span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line">fr2d.EndDraw();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">FrWnd <span class="title">myWnd</span><span class="params">(<span class="number">640</span>, <span class="number">480</span>, WndProc, Display, <span class="string">"HelloWorld"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(WINPARAMETERS)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!myWnd.Create(INITPARAMETERS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">hwnd = myWnd.GetHandle();</span><br><span class="line">Init();</span><br><span class="line">myWnd.Run();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建好一个窗体后，就可以使用Direct2D绘制了。&lt;/p&gt;
&lt;p&gt;Direct2D程序需要包含头文件d2d1.h，和静态库d2d1.lib。这里简单介绍一下Direct2D程序初始化过程。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Fr2D开发笔记" scheme="http://yoursite.com/tags/Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图形学" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="DirectX" scheme="http://yoursite.com/tags/DirectX/"/>
    
  </entry>
  
  <entry>
    <title>【Fr2D开发笔记】二、创建Window</title>
    <link href="http://yoursite.com/2019/08/02/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/02/【杂记】Fr2D开发笔记（二）/</id>
    <published>2019-08-02T13:42:33.000Z</published>
    <updated>2020-06-28T12:46:28.589Z</updated>
    
    <content type="html"><![CDATA[<p>在完成上次的Fr2D的控制台版本后，是时候把它变成一个真正的图形库了。控制台绘制显然是不理想的，因此，我选择了Direct2D。  </p><a id="more"></a><h1 id="一、WinAPI"><a href="#一、WinAPI" class="headerlink" title="一、WinAPI"></a>一、WinAPI</h1><p>调用Direct2D的前提是创建一个渲染对象窗体。所以，我们需要先使用WindowsAPI创建一个。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">HWND ghMainWnd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitWindowsApp</span><span class="params">(HINSTANCE instanceHandle, <span class="keyword">int</span> show)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, <span class="keyword">int</span> nShowCmd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!InitWindowsApp(hInstance, nShowCmd))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitWindowsApp</span><span class="params">(HINSTANCE instanceHandle, <span class="keyword">int</span> show)</span> </span>&#123;</span><br><span class="line">    WNDCLASS wc;</span><br><span class="line">    wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">    wc.lpfnWndProc = WndProc;</span><br><span class="line">    wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">    wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">    wc.hInstance = instanceHandle;</span><br><span class="line">    wc.hIcon = LoadIcon(<span class="number">0</span>, IDI_APPLICATION);</span><br><span class="line">    wc.hCursor = LoadCursor(<span class="number">0</span>, IDC_ARROW);</span><br><span class="line">    wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">    wc.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">    wc.lpszClassName = _T(<span class="string">"BasicWndClass"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RegisterClass(&amp;wc)) &#123;</span><br><span class="line">        MessageBox(<span class="number">0</span>, _T(<span class="string">"RegisterClass FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ghMainWnd = CreateWindow(</span><br><span class="line">        _T(<span class="string">"BasicWndClass"</span>),</span><br><span class="line">        _T(<span class="string">"Win32Basic"</span>),</span><br><span class="line">        WS_OVERLAPPEDWINDOW,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        CW_USEDEFAULT,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>,</span><br><span class="line">        instanceHandle,</span><br><span class="line">        <span class="number">0</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ghMainWnd == <span class="number">0</span>) &#123;</span><br><span class="line">        MessageBox(<span class="number">0</span>, _T(<span class="string">"CreateWindow FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ShowWindow(ghMainWnd, show);</span><br><span class="line">    UpdateWindow(ghMainWnd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (msg.message != WM_QUIT) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE)) &#123;</span><br><span class="line">            TranslateMessage(&amp;msg);</span><br><span class="line">            DispatchMessage(&amp;msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg) &#123;</span><br><span class="line">    <span class="keyword">case</span> WM_LBUTTONDOWN:</span><br><span class="line">        MessageBox(<span class="number">0</span>, _T(<span class="string">"Hello, World"</span>), _T(<span class="string">"Hello"</span>), MB_OK);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">        <span class="keyword">if</span> (wParam == VK_ESCAPE)</span><br><span class="line">            DestroyWindow(ghMainWnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是使用WINAPI创建一个窗体的最简代码了，包括注册这个窗体，获取的窗体句柄，消息循环和窗口过程回调函数。其实在vs中创建windows应用的话，vs会直接生成这些代码，但要便于使用于是将其封装。  </p><h1 id="二、FrWnd类"><a href="#二、FrWnd类" class="headerlink" title="二、FrWnd类"></a>二、FrWnd类</h1><p>这里将创建一个窗体个过程粗暴地封装成了FrWnd类，将窗口过程和Display设计成回调函数，Display函数负责写窗体的绘制语句，在注册新窗体时传入即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WINPARAMETERS HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR pCmdLine, int nShowCmd</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITPARAMETERS hInstance, nShowCmd</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrWnd</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">FrWnd();</span><br><span class="line">FrWnd(<span class="keyword">int</span> _height, <span class="keyword">int</span> _width, WNDPROC proc, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>()&gt; callback, LPCSTR _name);</span><br><span class="line"></span><br><span class="line"><span class="function">HWND <span class="title">GetHandle</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Create</span><span class="params">(HINSTANCE instanceHandle, <span class="keyword">int</span> show)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">HWND hwnd;</span><br><span class="line">LPCSTR name;</span><br><span class="line"><span class="keyword">int</span> height;</span><br><span class="line"><span class="keyword">int</span> width;</span><br><span class="line">WNDPROC proc;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>()&gt; Display;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">FrWnd::FrWnd() &#123;</span><br><span class="line">height = <span class="number">800</span>;</span><br><span class="line">width = <span class="number">600</span>;</span><br><span class="line">name = _T(<span class="string">"Test"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FrWnd::FrWnd(<span class="keyword">int</span> _height, <span class="keyword">int</span> _width, WNDPROC _proc, <span class="built_in">std</span>::function&lt;<span class="keyword">bool</span>()&gt; callback, LPCSTR _name = _T(<span class="string">"Test"</span>)) &#123;</span><br><span class="line">height = _height;</span><br><span class="line">width = _width;</span><br><span class="line">Display = callback;</span><br><span class="line">name = _name;</span><br><span class="line">proc = _proc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> FrWnd::Create(HINSTANCE instanceHandle, <span class="keyword">int</span> show) &#123;</span><br><span class="line">WNDCLASS wc;</span><br><span class="line">wc.style = CS_HREDRAW | CS_VREDRAW;</span><br><span class="line">wc.lpfnWndProc = proc;</span><br><span class="line">wc.cbClsExtra = <span class="number">0</span>;</span><br><span class="line">wc.cbWndExtra = <span class="number">0</span>;</span><br><span class="line">wc.hInstance = instanceHandle;</span><br><span class="line">wc.hIcon = LoadIcon(<span class="number">0</span>, IDI_APPLICATION);</span><br><span class="line">wc.hCursor = LoadCursor(<span class="number">0</span>, IDC_ARROW);</span><br><span class="line">wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);</span><br><span class="line">wc.lpszMenuName = <span class="number">0</span>;</span><br><span class="line">wc.lpszClassName = _T(<span class="string">"BasicWndClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!RegisterClass(&amp;wc)) &#123;</span><br><span class="line">MessageBox(<span class="number">0</span>, _T(<span class="string">"RegisterClass FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hwnd = CreateWindow(</span><br><span class="line">_T(<span class="string">"BasicWndClass"</span>),</span><br><span class="line">name,</span><br><span class="line">WS_OVERLAPPEDWINDOW,</span><br><span class="line">CW_USEDEFAULT,</span><br><span class="line">CW_USEDEFAULT,</span><br><span class="line">height,</span><br><span class="line">width,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line"><span class="number">0</span>,</span><br><span class="line">instanceHandle,</span><br><span class="line"><span class="number">0</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (hwnd == <span class="number">0</span>) &#123;</span><br><span class="line">MessageBox(<span class="number">0</span>, _T(<span class="string">"CreateWindow FAILED"</span>), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShowWindow(hwnd, show);</span><br><span class="line">UpdateWindow(hwnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> FrWnd::Run() &#123;</span><br><span class="line">MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">while</span> (msg.message != WM_QUIT) &#123;</span><br><span class="line"><span class="keyword">if</span> (PeekMessage(&amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, PM_REMOVE)) &#123;</span><br><span class="line">TranslateMessage(&amp;msg);</span><br><span class="line">DispatchMessage(&amp;msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Display();<span class="comment">//此处为回调函数</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">int</span>)msg.wParam;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HWND FrWnd::GetHandle() &#123;</span><br><span class="line"><span class="keyword">return</span> hwnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"frwnd.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (msg) &#123;</span><br><span class="line"><span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">DestroyWindow(hWnd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">PostQuitMessage(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefWindowProc(hWnd, msg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Display</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function">FrWnd <span class="title">myWnd</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, WndProc, Display, <span class="string">"test"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">WinMain</span><span class="params">(WINPARAMETERS)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!myWnd.Create(INITPARAMETERS))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">myWnd.Run();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，就创建了一个窗体。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在完成上次的Fr2D的控制台版本后，是时候把它变成一个真正的图形库了。控制台绘制显然是不理想的，因此，我选择了Direct2D。  &lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Fr2D开发笔记" scheme="http://yoursite.com/tags/Fr2D%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
      <category term="图形学" scheme="http://yoursite.com/tags/%E5%9B%BE%E5%BD%A2%E5%AD%A6/"/>
    
      <category term="DirectX" scheme="http://yoursite.com/tags/DirectX/"/>
    
  </entry>
  
  <entry>
    <title>【杂记】博客搭建记</title>
    <link href="http://yoursite.com/2019/08/02/%E3%80%90%E6%9D%82%E8%AE%B0%E3%80%91%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0/"/>
    <id>http://yoursite.com/2019/08/02/【杂记】博客搭建记/</id>
    <published>2019-08-02T12:16:41.000Z</published>
    <updated>2019-08-02T13:39:30.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一"><a href="#一" class="headerlink" title="一"></a>一</h1><p>地灵殿这个博客是2017-12-26就开始了，因为当时搞OI在洛谷上刷题，旧站使用了洛谷博客。然而用着用着就发现luogu博客如果不动歪脑筋的话就很不自由，许多功能缺失都让人觉得比较难受。尤其是缺少文章归档，随着文章的增多，管理就十分复杂。</p><a id="more"></a><p>之前就一直想自己搭一个博客解决这个问题。于是就去向前段时间买了个nb域名的阿魏请教（本站友链中有他的blog链接(*/ω＼*)），给我介绍了他租服务器、买域名的故事。听完，我就咕了一段时间（等我有钱了我也……）。</p><p>直到又从阿魏得知，有一种使用Hexo+Github的赤贫套餐。嗯，正合我意。于是立即开始了搭建。</p><h1 id="二"><a href="#二" class="headerlink" title="二"></a>二</h1><p>好在我使用GitHub，所以git相关的操作已经通了，照着hexo的教程一步步装得很顺利：<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802204950.jpg" alt="QQ20190802204950.jpg"></p><p>然后就是搭自己的博客了，将主题换成了yilia，简单在配置文件中注册了一下：<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802205023.jpg" alt="QQ20190802205023.jpg">  </p><h1 id="三"><a href="#三" class="headerlink" title="三"></a>三</h1><p>基本功能完成了，之后就是想办法搞各种花样了</p><ul><li>添加tag、category，实现了功能（归档功能终于实现了） </li><li>实现文章置顶、置顶级别</li><li>左侧四个个人主页/联系方式</li><li>左侧菜单嵌入音乐播放器<br>使用网易云音乐网页版生成的链接，嵌入对应位置即可<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802205051.jpg" alt="QQ20190802205051.jpg"></li><li>添加访问量统计</li><li>显示文章结构<br><img src="https://www.z4a.net/images/2019/08/02/ESR8BY3ZQTMQAI0W77.png" alt="ESR8BY3ZQTMQAI0W77.png"></li><li>添加左侧菜单栏分类，增加about页面、地灵殿旧址</li><li>添加评论系统功能<br>阿魏给我推荐了valine，然而研究后发现要实名注册，于是立即放弃了（<br>最后使用了gitment，也是github应用，相性好。<br>可以用npm，安装同样简单，然而遇到了些问题，无法评论。原来是gitment那人的服务器到期了，网上找了个，解决了。<br><img src="https://www.z4a.net/images/2019/08/02/QQ20190802211805.png" alt="QQ20190802211805.png"></li><li>修改背景色</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; class=&quot;headerlink&quot; title=&quot;一&quot;&gt;&lt;/a&gt;一&lt;/h1&gt;&lt;p&gt;地灵殿这个博客是2017-12-26就开始了，因为当时搞OI在洛谷上刷题，旧站使用了洛谷博客。然而用着用着就发现luogu博客如果不动歪脑筋的话就很不自由，许多功能缺失都让人觉得比较难受。尤其是缺少文章归档，随着文章的增多，管理就十分复杂。&lt;/p&gt;
    
    </summary>
    
      <category term="开发笔记" scheme="http://yoursite.com/categories/%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="杂记" scheme="http://yoursite.com/tags/%E6%9D%82%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>这是好的</title>
    <link href="http://yoursite.com/2019/08/01/%E8%BF%99%E6%98%AF%E5%A5%BD%E7%9A%84/"/>
    <id>http://yoursite.com/2019/08/01/这是好的/</id>
    <published>2019-08-01T09:51:14.000Z</published>
    <updated>2019-08-01T12:50:45.584Z</updated>
    
    <content type="html"><![CDATA[<p>本站总访问量<span id="busuanzi_value_site_pv"></span>次<br>本站访客数<span id="busuanzi_value_site_uv"></span>人次</p><h1 id="好了"><a href="#好了" class="headerlink" title="好了"></a>好了</h1><p><em>还有什么人</em><br><strong>要提问？</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;br&gt;本站访客数&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;人次&lt;/p&gt;
&lt;h1 id=&quot;好了&quot;&gt;&lt;a href=&quot;#好了&quot; class=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>【小课堂】八、算法初步</title>
    <link href="http://yoursite.com/2019/07/24/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E5%85%AB%E3%80%81%E7%AE%97%E6%B3%95%E5%88%9D%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/07/24/【小课堂】八、算法初步/</id>
    <published>2019-07-24T08:52:25.000Z</published>
    <updated>2019-08-05T09:00:02.722Z</updated>
    
    <content type="html"><![CDATA[<p>至此，小课堂基础篇的语法部分就告一段落了，我们已经学习了最常用的C/C++语言语法；从哲学的角度说，现在我们已经可以使用C/C++语言的这些语句实现计算机能做的一切功能了。然而在现实的编程操作过程中却并不这么理想，好像经常会出现有一个需求却不知道如何实现的情况（如果你在之前的课程中打星号的习题上遇到过困难的话）；这就是我们学习<strong>算法</strong>的目的。<br>在这一节，我们将了解什么是算法，了解一些常用的基础算法以及实现，并初步学习计算<strong>算法复杂度</strong>的方法。  </p><a id="more"></a><h1 id="什么是算法"><a href="#什么是算法" class="headerlink" title="什么是算法"></a>什么是算法</h1><p>算法就是解决问题的一系列流程。<br>算法的概念始终伴随着我们的数学学习过程（只是时不时地被淡化了），现在回忆小时候学用竖式计算多位数加法的过程：从低位开始，按位相加，超过10了要进位，进位要参与下一位的运算中，直到算到某数到头了，另一个数剩余部分抄下来，算法结束。<br>这个看似简单的算法，却有着大用处——这就是<strong>高精度计算</strong>。<br>请看下例：<br><strong>例8.1</strong><br> <em>输入两个正整数a,b（a,b&lt;$10^{500}$），输出a+b的值</em>   </p><p>我们发现，在C/C++语言中数的大小受到限制，而假如我们要用C/C++语言进行上百甚至上千位的计算，使用内置的int（long long也不行）就无能为力了。而此时，使用竖式加法的算法就能解决这个问题：  </p><ul><li>使用字符串读取两个大整数  </li><li>使用竖式加法算法进行计算，结果储存在另一个字符串中   </li><li>输出结果字符串  </li></ul><p>于是，我们就可以这么写：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高精度加法算法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">char</span> s1[<span class="number">1000</span>],s2[<span class="number">1000</span>],ans[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s1[<span class="number">0</span>]==<span class="string">'0'</span>&amp;&amp;s2[<span class="number">0</span>]==<span class="string">'0'</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(ans,<span class="string">"0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> al=<span class="built_in">strlen</span>(s1),bl=<span class="built_in">strlen</span>(s2);</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,b[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;,c[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> i,j,jw=<span class="number">0</span>,t1,t2=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;al;i++)</span><br><span class="line">        a[i]=s1[al<span class="number">-1</span>-i]-<span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;bl;i++)</span><br><span class="line">        b[i]=s2[bl<span class="number">-1</span>-i]-<span class="string">'0'</span>;</span><br><span class="line">    </span><br><span class="line">    t1=max(al,bl);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;t1;i++)&#123;</span><br><span class="line">        c[i]=a[i]+b[i]+jw;</span><br><span class="line">        jw=c[i]/<span class="number">10</span>;</span><br><span class="line">        c[i]%=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    c[i]=jw;</span><br><span class="line">    <span class="keyword">while</span>(c[i]==<span class="number">0</span>)i--;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        ans[t2]=c[i]+<span class="string">'0'</span>;</span><br><span class="line">        t2++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans[t2]=<span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s%s"</span>,s1,s2);</span><br><span class="line">    add();</span><br><span class="line">    <span class="built_in">puts</span>(ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h1><p>在设计出一个好的算法之前，首先要思考如何评判一个好的算法。在使用计算机的过程中，我们知道完成一个相同的任务，如果一个软件占用更小的内存，需要更少的运行时间（意味着更流畅的用户体验），那么它是更优的。这里引入<strong>空间复杂度</strong>和<strong>时间复杂度</strong>的概念。<br>由于复杂度的概念有确切的数学定义，对于给定算法也有严格的复杂度计算、证明方法；这里只是做初步介绍。<br>这里的<strong>空间</strong>就是内存空间的占用，而<strong>时间</strong>则是运算量对运行时间的占用。然而要注意，所谓<strong>复杂度</strong>并非指程序一次运行过程中占用空间或时间的多少，而是<strong>空间</strong>、<strong>时间</strong>的占用随<strong>输入规模</strong>的<strong>变化快慢</strong>。<br>如何计算时间复杂度？<br>我们可以将程序的语句执行次数可以用一个<strong>与输入有关的</strong>代数式表示，取这个代数式的最高次项且忽略此项系数作为时间复杂度。<br>例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//A</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>程序A中的cout语句执行了$5$次，与输入无关，为一个常数（也可以说最高次项是零次项），我们称这段程序的时间复杂度为$O(1)$，<strong>常数时间复杂度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>程序B中的cin语句执行了1次，cout语句执行了$n$次，与输入n有关，运算次数是$n+1$（最高次项是n的一次项），我们称这段程序的时间复杂度为$O(n)$，<strong>线性级时间复杂度</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">" "</span>&lt;&lt;j&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>程序C中的cin语句执行了1次，第一个循环cout语句执行了 $ 2*n*n $ 次，第二个循环cout语句执行了 $n$ 次，运算次数是$2n^2+n+1$（最高次项是n的二次项），我们称这段程序的时间复杂度为 $O(n^2)$ ，<strong>平方级时间复杂度</strong>。</p><p>如此定义时间复杂度的原因是：许多算法往往在输入较小的情况下都差不多（都是瞬间解决），而随着输入增大，运算需要的时间也会增加，但此时不同复杂度的算法增长快慢也不同。一个好的算法在数据量很大的情况下依然有好的表现。<br><img src="https://www.z4a.net/images/2019/08/02/740a41ac12dba81c1c5bc9bef895102a.png" alt="740a41ac12dba81c1c5bc9bef895102a.png"><br>图8.1，摘自《数据结构与算法分析：C语言描述》<br>下面将以排序算法为例体验不同算法复杂度的不同，并介绍算法复杂度计算方法。</p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>在之前学习分支、循环、数组的时候，都做过关于排序的题；而在高一信息课上也曾学过<strong>冒泡排序</strong>算法。原因一是因为它是个很好的例子；二是排序确实是个重要的算法——试想如果一本词典不按字典序，而是随机编写，那么我们每次查询都要从头翻起。排序是快速查找的基础。  </p><h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>那么如何得到一个有序的序列（排序）呢？比如，给定一个长度为n的数组，要求从小到大排序。我们先想简单一些：我们先找最小的，放第一个；然后找第二小的，放第二个……这样找n次，就得到了一个从小到大的序列：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>],b[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">bool</span> visited[<span class="number">1000</span>]=&#123;<span class="number">0</span>&#125;;     <span class="comment">//标记是否取过</span></span><br><span class="line">    <span class="keyword">int</span> m,position;             <span class="comment">//记录最小值</span></span><br><span class="line">    <span class="keyword">int</span> infinity=<span class="number">2147483647</span>;    <span class="comment">//这是最大的可能值（int类型的上限）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;      <span class="comment">//找n遍</span></span><br><span class="line">        m=infinity;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)   <span class="comment">//从头找到尾</span></span><br><span class="line">            <span class="keyword">if</span>(a[j]&lt;m &amp;&amp; !visited[j])&#123;<span class="comment">//a[j]如果比当下的最小值还小，且没取过</span></span><br><span class="line">                m=a[j];         <span class="comment">//新的最小值</span></span><br><span class="line">                position=j;     <span class="comment">//记录位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        b[i]=m;                 <span class="comment">//放入第i个最小值 </span></span><br><span class="line">        visited[position]=<span class="number">1</span>;    <span class="comment">//标记 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,b[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>花了些工夫，也实现了这个功能，看上去就很复杂——看来想起来简单的算法未必是最好的。了解了复杂度的概念后，我们可以从时间复杂度和空间复杂度两个角度评判这个算法，再想办法加以改进。  </p><ul><li>时间复杂度：<br>不计输入输出，排序部分循环执行$n*n$次，时间复杂度为$O(n^2)$  </li><li>空间复杂度：<br>不计原始数组，排序部分共使用了一个长度为n的整型数组b，和长度为n的布尔型数组visited，空间复杂度为$O(n)$   </li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>如果我们从空间方面考虑优化，就会发现找到最小值之后不一定要放在另一个数组b中，而可以直接在原数组a中改变顺序：找到最小值后与原a[1]交换，找到第二小值后与原a[2]交换……最终有序序列存放在a中，上面的b数组和visited数组就节省掉了。<br>于是我们得到了以下经过优化的代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> m,position,t;             <span class="comment">//记录最小值</span></span><br><span class="line">    <span class="keyword">int</span> infinity=<span class="number">2147483647</span>;    <span class="comment">//这是最大的可能值（int类型的上限）</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;      <span class="comment">//找n遍</span></span><br><span class="line">        m=infinity;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;=n;j++)   <span class="comment">//在剩余的元素中找 </span></span><br><span class="line">            <span class="keyword">if</span>(m&gt;a[j])&#123;</span><br><span class="line">                m=a[j];</span><br><span class="line">                position=j;</span><br><span class="line">            &#125;</span><br><span class="line">        t=a[i];                 <span class="comment">//放入a[i]的位置（交换） </span></span><br><span class="line">        a[i]=a[position];</span><br><span class="line">        a[position]=t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]); </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：<br>不计输入输出，排序部分循环执行 $\frac{1}{2}*n*n$ 次，时间复杂度仍为$O(n^2)$（常数比之前的稍小，但仍是同一级别）  </li><li>空间复杂度：<br>不计原始数组，排序部分只使用了几个临时变量，空间复杂度为常数$O(1)$     </li></ul><p>经过上述优化的这种排序算法学名为<strong>选择排序</strong>。正如上面分析的，选择排序的时间复杂度为$O(n^2)$，空间复杂度为$O(1)$。  </p><h2 id="更进一步的优化"><a href="#更进一步的优化" class="headerlink" title="*更进一步的优化"></a>*更进一步的优化</h2><p>上述选择排序的时间复杂度$O(n^2)$仍然可以进一步优化：内层循环$O(n)$的寻找最小值操作可以借助一种叫<strong>堆</strong>的<strong>数据结构</strong>将复杂度降低至$O(logn)$，从而使整体复杂度降为$O(nlogn)$。这种排序算法名为<strong>堆排序</strong>，然而由于涉及数据结构的知识，这里不详细介绍，如感兴趣可自行搜索。  </p><p>这里介绍一种时间复杂度同样是$O(nlogn)$的算法，<strong>归并排序</strong>。</p><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="*归并排序"></a>*归并排序</h2><p>我们先引入一种将两个有序序列合并成一个有序序列的算法：<strong>二路归并</strong>。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;        <span class="comment">//有序数组a，共6个元素 </span></span><br><span class="line">    <span class="keyword">int</span> b[<span class="number">10</span>]=&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">12</span>,<span class="number">13</span>&#125;;    <span class="comment">//有序数组b ，共7个元素 </span></span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">20</span>];                      <span class="comment">//合并的新数组 </span></span><br><span class="line">    <span class="keyword">int</span> pa=<span class="number">0</span>,pb=<span class="number">0</span>,k=<span class="number">0</span>;              <span class="comment">//a,b,t数组的当前位置，初始为0 </span></span><br><span class="line">    <span class="keyword">while</span>(pa&lt;<span class="number">6</span> &amp;&amp; pb&lt;<span class="number">7</span>)             <span class="comment">//a,b数组都没到末尾，则循环 </span></span><br><span class="line">        <span class="keyword">if</span>(a[pa]&lt;b[pb])&#123;            <span class="comment">//如果当前是a的元素小</span></span><br><span class="line">            t[k]=a[pa];             <span class="comment">//则t中放入a的当前元素 </span></span><br><span class="line">            pa++;                   <span class="comment">//指向a的下一个元素 </span></span><br><span class="line">            k++;                    <span class="comment">//指向t的下一个空位 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;                       <span class="comment">//否则是b的元素小 </span></span><br><span class="line">            t[k]=b[pb];</span><br><span class="line">            pb++;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">while</span>(pa&lt;<span class="number">6</span>)&#123;                    <span class="comment">//如果a数组还没到末尾 </span></span><br><span class="line">        t[k]=a[pa];                 <span class="comment">//将a的元素接在t数组末尾 </span></span><br><span class="line">        pa++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(pb&lt;<span class="number">7</span>)&#123;                    <span class="comment">//否则将b数组接在t的末尾 </span></span><br><span class="line">        t[k]=b[pb];                 <span class="comment">//注意这两个循环不会都执行 </span></span><br><span class="line">        pb++;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">13</span>;i++)           <span class="comment">//输出结果：1 2 2 3 5 6 6 7 7 8 9 12 13 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,t[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法总共只将a,b两个数组从头扫描至末尾，如果两个序列长度分别为$m,n$，则二路归并的时间复杂度为$O(m+n)$  </p><p>归并排序就是借助二路归并和递归思想实现的排序算法：<br>先将排序序列平分成左右两个部分：</p><ul><li>如果排序的序列的两个部分都是有序序列，那么我们可以用二路归并排成有序，排序完成。  </li><li>如果排序的序列左右两个部分不是有序序列，那么就继续平分成两个部分进行归并排序（递归）  </li><li>如果分割到只剩一个元素了，那左右两部分就一定是有序的，直接归并（递归的基本条件）  </li></ul><p><img src="https://gss3.bdstatic.com/7Po3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike92%2C5%2C5%2C92%2C30/sign=236fa62859b5c9ea76fe0bb1b450dd65/c8177f3e6709c93d673b9ed49d3df8dcd00054c3.jpg" alt><br>于是，归并排序就可以这样实现：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000</span>],t[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;    <span class="comment">//两个参数分别为排序的左右边界</span></span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span>;             <span class="comment">//区间只有一个元素 </span></span><br><span class="line">    <span class="keyword">int</span> mid=(l+r)/<span class="number">2</span>;            <span class="comment">//中间位置下标 </span></span><br><span class="line">    mergesort(l,mid);           <span class="comment">//递归排序左半边 </span></span><br><span class="line">    mergesort(mid+<span class="number">1</span>,r);         <span class="comment">//递归排序右半边 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,k=l;        <span class="comment">//递归结束，此时左右两序列已经有序 </span></span><br><span class="line">                                <span class="comment">//下面将两部分进行二路归并 </span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=r)</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;a[j])&#123;</span><br><span class="line">            t[k]=a[i];i++;k++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            t[k]=a[j];j++;k++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)&#123;</span><br><span class="line">        t[k]=a[i];k++;i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r)&#123;</span><br><span class="line">        t[k]=a[j];k++;j++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=l;i&lt;=r;i++)</span><br><span class="line">        a[i]=t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]); </span><br><span class="line">    </span><br><span class="line">    mergesort(<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个长度为$n$的数组，每次二分区间直到单元素，一共是$logn$次（在信息学中，$log$默认的底数为2）；而上面分析二路归并的复杂度为$O(n)$级，因此，归并排序的时间复杂度为$O(nlogn)$，是一种高效的排序算法。<br>从归并排序一例中，我们也认识到递归的真正威力。  </p><h1 id="搜索算法初步"><a href="#搜索算法初步" class="headerlink" title="*搜索算法初步"></a>*搜索算法初步</h1><p>计算机的最大优势就是快速的运算能力，我们可以利用这点进行人工无法实现的大量重复劳动。然而要达到这一要求也需要算法的支持，这就是<strong>搜索算法</strong>。  </p><h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><p><strong>例8.2</strong><br><em>有A~E五人，和1~5五本书，每个人对每本书各有喜好（如下表所示），找出所有让每个人满意的发书方案</em><br><img src="https://www.z4a.net/images/2019/08/02/82.png" alt="82.png"><br>这题的思路很简单，把所有发书情况（$P^5_5$）全部枚举，判断是否符合要求，输出符合要求的方法。然而，怎么让计算机枚举这些情况呢？<br>我们首先使用一个二维数组like表示上面的表格，like[i][j]就表示第i个人是否喜欢第j本书（下标从1开始）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> like[<span class="number">10</span>][<span class="number">10</span>]=&#123; &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><p>然后就是枚举了。这里引入<strong>深度优先搜索</strong>（<strong>dfs</strong>）算法解决这一问题。<br>我们先定义数组a，a[i]表示第i个人发到的书的编号，如a[2]=5表示第二个人发到第五本书。然后我们就可以试着按照要求填写这一数组，当a[1]到a[5]全部填满时就是满足条件的一组解了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];<span class="comment">//记录结果</span></span><br><span class="line"><span class="keyword">bool</span> b[<span class="number">10</span>];<span class="comment">//记录书的发放情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;<span class="comment">//参数表示当前发到第i个人</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)<span class="comment">//枚举五本书</span></span><br><span class="line">        <span class="keyword">if</span>(!b[j]&amp;&amp;like[i][j])&#123;<span class="comment">//如果第j本书没有发放，并且第i人喜欢第j本书</span></span><br><span class="line">            a[i]=j;<span class="comment">//发书：将第i个人的书标记为第j本</span></span><br><span class="line">            b[j]=<span class="number">1</span>;<span class="comment">//标记第j本书已经发出</span></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">5</span>)write();<span class="comment">//如果到了第五个人，说明五本书都已经成功发放，就输出</span></span><br><span class="line">            <span class="keyword">else</span> book(i+<span class="number">1</span>);<span class="comment">//发下一个人的书</span></span><br><span class="line">            b[j]=<span class="number">0</span>;<span class="comment">//此时在i发第j本情况下，第i+1个人的情况已枚举完毕，于是解除第j本的标记，准备开始发第j+1本</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在请用纸笔模拟一遍上述代码的运行过程和输出。  </p><p>我们可以发现，深度优先搜索的过程就是利用了搜索时每一个阶段的相似性进行递归求解；而求解过程符合思考时的逻辑，先 <em>深度优先</em> 地寻找到一组解，找完一组解后当前递归的结束，回退以寻找下一组解，这样可以很好的检验每一组解，保证解的正确性；最后的运行次数也就是本题的枚举次数：$5!$次，保证不重不漏。</p><p>由此我们可以得到深度优先搜索的一般形式：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=maxj;j++)</span><br><span class="line">        <span class="keyword">if</span>(新节点符合条件)&#123;</span><br><span class="line">            记录新节点;</span><br><span class="line">            <span class="keyword">if</span>(到目标节点)输出;</span><br><span class="line">            <span class="keyword">else</span> dfs(i+<span class="number">1</span>);</span><br><span class="line">            删除节点;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中记录节点与删除节点的语句应为逆运算关系，保证回到原先状态，进行下一次搜索。<br>需要注意的是，深度优先搜索算法的时间复杂度是指数级的，取决于你需要枚举的种类数，可以发现上例中五个人五本书$n=5$如果换成$n=100$，枚举种数将是天文数字，也就不能使用搜索算法求解了。</p><p>搜索算法补充阅读（友情链接）：<a href="https://blog.csdn.net/qq_40892508/article/details/91420286" target="_blank" rel="noopener">比较深奥</a></p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、什么是算法？为什么要学习算法？算法和代码的关系是什么？<br>2、什么是算法复杂度？如何计算时间/空间复杂度？复杂度这一概念有什么作用？<br>3、既然排序算法的功能都完全一致，为什么还要发明那么多种不同的排序算法？  </p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、 输入两个正整数a,b（a,b&lt;$10^{500}$），输出a-b的值，并分析你的算法的复杂度<br>*2、  输入两个正整数a,b（a,b&lt;$10^{500}$），输出a*b的值，并分析你的算法的复杂度<br>**3、快速排序是也是一种高效的排序算法。与归并排序类似，快速排序算法也是使用了分治和递归的思想，其中一种描述如下：  </p><ul><li>取序列的正中间元素作为标准，将序列分成两部分，将比标准小的元素放在标准左边，大的元素放在右边  </li><li>对左右两部分也分别进行快速排序（递归）</li><li>直到分割成单元素（递归的基本条件）  </li></ul><p><a href="https://www.bilibili.com/video/av10076626?from=search&seid=2450896441342489123" target="_blank" rel="noopener">也可以看看这个视频帮助理解</a><br>请按照描述（可仿照归并排序）实现快速排序算法，并分析其复杂度<br>**4、八皇后问题为：国际象棋棋盘上放置8个互相不能攻击到的皇后的摆法有多少种？（国际象棋棋盘为8*8，皇后可以攻击到同行、列与两条对角线的棋子），使用<strong>深度优先搜索</strong>算法求解八皇后问题   </p><p>提示：可以使用以下方法传递数组为函数的参数，<strong>不同于普通参数的传值，数组作为参数传递的是数组自身。这意味着函数中对传入的数组进行操作将改变这个数组</strong>  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ArrayProcedure</span><span class="params">(<span class="keyword">int</span> a[])</span></span>&#123;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        t[i]=i;</span><br><span class="line">    </span><br><span class="line">    ArrayProcedure(t);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;t[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>10<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;至此，小课堂基础篇的语法部分就告一段落了，我们已经学习了最常用的C/C++语言语法；从哲学的角度说，现在我们已经可以使用C/C++语言的这些语句实现计算机能做的一切功能了。然而在现实的编程操作过程中却并不这么理想，好像经常会出现有一个需求却不知道如何实现的情况（如果你在之前的课程中打星号的习题上遇到过困难的话）；这就是我们学习&lt;strong&gt;算法&lt;/strong&gt;的目的。&lt;br&gt;在这一节，我们将了解什么是算法，了解一些常用的基础算法以及实现，并初步学习计算&lt;strong&gt;算法复杂度&lt;/strong&gt;的方法。  &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】七、文件</title>
    <link href="http://yoursite.com/2019/07/23/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E4%B8%83%E3%80%81%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/07/23/【小课堂】七、文件/</id>
    <published>2019-07-23T02:54:52.000Z</published>
    <updated>2019-08-01T16:24:32.866Z</updated>
    
    <content type="html"><![CDATA[<p>使用控制台输入会对我们输入量个大小产生限制，也不利于输出数据的永久保存。因此，我们时常使用程序进行<strong>文件操作</strong>解决这一问题。   </p><a id="more"></a><h1 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h1><p>我们首先需要头文件stdio.h（C++则是cstdio）<br>在还未学习指针时，我们可以先将文件指针理解为操作文件的一种特殊的数据类型。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FILE *myFileIn, *myFileOut;</span><br></pre></td></tr></table></figure><p>如此便声明了两个文件指针变量myFileIn和myFileOut，然后我们需要使用fopen函数，将它们指向硬盘中的真实的文件，以实现对文件的操作：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(文件名,操作类型)</span></span>;</span><br></pre></td></tr></table></figure><p>如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myFileIn = fopen(<span class="string">"testIn.txt"</span>,<span class="string">"r"</span>);</span><br><span class="line">myFileOut = fopen(<span class="string">"testOut.txt"</span>,<span class="string">"w"</span>);</span><br></pre></td></tr></table></figure><p>我们让myFileIn指向与程序同目录的testIn.txt文件，并注册为只读”r”;让myFileOut指向与程序同目录的testOut.txt文件，并注册为只写”w”。操作类型为写入，而路径下还没有此文件，程序就会创建这个文件；而如果此文件已经存在，程序则会<strong>覆盖</strong>它。<br>fopen还有其他的操作类型，用于不同的文件使用场合，这里不作介绍，可自行查询。  </p><p>这样就完成了文件指针的初始化，在程序的编写中，我们就可以通过myFileIn使用硬盘中的testIn.txt文件，我们称此文件指针为一个<strong>文件句柄</strong>（<strong>file handle</strong>）。  </p><h1 id="文件输入输出"><a href="#文件输入输出" class="headerlink" title="文件输入输出"></a>文件输入输出</h1><p>有了文件句柄，就可以使用文件进行输入输出了：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="built_in">fscanf</span>(myFileIn,<span class="string">"%d"</span>,&amp;a);</span><br><span class="line"><span class="built_in">fprintf</span>(myFileOut,<span class="string">"%d\n"</span>,a+<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>先在同目录下创建一个文件testIn.txt，输入一个数，然后运行程序。我们发现目录下生成了一个文件testOut.txt，输出了这个数加一。  </p><p>fscanf、fprintf函数与scanf、printf函数类似，唯一的区别就是需要一个提供操作的文件句柄。  </p><h1 id="文件的结束（EOF）"><a href="#文件的结束（EOF）" class="headerlink" title="文件的结束（EOF）"></a>文件的结束（EOF）</h1><p>fscanf函数还可以返回文件的结束信息（End Of File，<strong>EOF</strong>），在读完文件时给予反馈：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>],i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">fscanf</span>(myFileIn,<span class="string">"%d"</span>,&amp;a)!=EOF )i++;</span><br></pre></td></tr></table></figure><p>即可实现读取直到读完文件停止。</p><h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><p>文件使用完毕后，需要使用fclose函数关闭文件，解除此程序对文件的占用。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fclose(myFileIn);</span><br><span class="line">fclose(myFileOut);</span><br></pre></td></tr></table></figure><p>以上是对于文本文件（ascii）的基本操作，C/C++语言还提供更多丰富的文件操作，如对于二进制文件的fread/fwrite，涉及一些文件编码知识，可自行探索。  </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、我们为什么要引进文件操作？<br>2、什么是文件句柄？使用文件为什么要引入文件句柄？  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用控制台输入会对我们输入量个大小产生限制，也不利于输出数据的永久保存。因此，我们时常使用程序进行&lt;strong&gt;文件操作&lt;/strong&gt;解决这一问题。   &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】六、字符串</title>
    <link href="http://yoursite.com/2019/07/17/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E5%85%AD%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/07/17/【小课堂】六、字符串/</id>
    <published>2019-07-17T04:31:46.000Z</published>
    <updated>2019-08-03T16:25:08.949Z</updated>
    
    <content type="html"><![CDATA[<p>我们经常需要使用计算机处理大量的字符，因而C/C++引入<strong>字符串</strong>(string)以支持对大量字符操作。<br>其中，C++语言提供了<strong>C风格字符串</strong>和<strong>C++风格字符串</strong>（STL）两种选择：C风格的字符串操作与C语言完全一致，而C++风格的字符串则以面向对象的范式支持了更多操作。  </p><a id="more"></a><h1 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h1><p>C/C++中的字符串常量就是以英文双引号括起来的一段字符：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello,world"</span></span><br></pre></td></tr></table></figure><p>像scanf，printf函数，传的参数也就是字符串常量。</p><h1 id="C风格的字符串"><a href="#C风格的字符串" class="headerlink" title="C风格的字符串"></a>C风格的字符串</h1><p>在C语言中，字符串就是一种特殊的<strong>字符型数组</strong>，唯一与普通字符型数组不同的是，字符串以一个特殊字符’\0’（ASCII码也为0）结尾。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;<span class="comment">//这是一个字符型数组</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">100</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'\0'</span>&#125;;<span class="comment">//这是一个C风格字符串</span></span><br></pre></td></tr></table></figure><p>由于数组初始化时会将未赋值的空间赋为0，因此字符数组a也可以看做一个字符串，而b[3]==’\0’就是一个字符串。但为了区分，我们有必要在字符串结尾加一个’\0’做标志。   </p><h2 id="C风格输入输出"><a href="#C风格输入输出" class="headerlink" title="C风格输入输出"></a>C风格输入输出</h2><p>引入字符串概念后，就可以对字符进行整体的输入输出操作了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br></pre></td></tr></table></figure><p>输入：<br>abc<br>输出：<br>abc<br>使用scanf将字符串”abc”整体读入字符串s，并使用printf进行整体的输出。  </p><p>这里有个重要的细节：用scanf输入变量时，需要使用取地址运算符&amp;进行操作，而输入字符串时则不加，这一差异需要用心记忆。（原因则较为复杂不必深究，与数组类型的本质有关。数组名实际上是指向首元素的一个特殊指针，因而字符串传入时相当于直接传入了地址。）  </p><h2 id="C风格字符串的操作"><a href="#C风格字符串的操作" class="headerlink" title="C风格字符串的操作"></a>C风格字符串的操作</h2><p>另外，C语言还提供了更多现成的字符串操作（即定义了许多现成的字符串函数），都在头文件string.h中；如果使用C++，头文件则是cstring，里面的内容是完全一样的。这里只是简单介绍常用的一些操作，更多操作如有需要可以自行查询。  </p><h3 id="gets、puts"><a href="#gets、puts" class="headerlink" title="gets、puts"></a>gets、puts</h3><p>与scanf，printf类似，是字符串的输入输出函数。只是scanf读取字符串和其他数据一样，遇到空白符号即停止（空格、回车），而gets允许读取代空格的字符串：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>abc def<br>输出：<br>abc  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    gets(a);</span><br><span class="line">    <span class="built_in">puts</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>abc def<br>输出：<br>abc def  </p><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><p>和数组一样，C风格的字符串不允许直接赋值为一个字符串常量：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//禁止： s="hello";</span></span><br></pre></td></tr></table></figure><p>要赋值一个字符串，需要使用函数strcpy（string copy）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s1,<span class="string">"hello"</span>);</span><br><span class="line"><span class="built_in">puts</span>(s1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s2[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s2,s1);</span><br><span class="line"><span class="built_in">puts</span>(s2);</span><br></pre></td></tr></table></figure><p>输出：<br>hello<br>hello  </p><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><p>用于比较两个字符串的大小（也就是<strong>字典序</strong>，就是英文字典中单词的排序方式）。<br>strcmp(s1,s2)：如果s1&gt;s2返回正整数，s1=s2返回0，s1&lt;s2返回负整数：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">20</span>],s2[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s1,<span class="string">"apple"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(s2,<span class="string">"application"</span>);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(s1,s2)&gt;<span class="number">0</span>) <span class="built_in">puts</span>(s1);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(s2);</span><br></pre></td></tr></table></figure><p>输出：<br>application  </p><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h3><p>返回一个字符串的长度（字符数，’\0’不计在内）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(<span class="string">"apple"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(s,<span class="string">"ball"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="built_in">strlen</span>(s));</span><br></pre></td></tr></table></figure><p>输出：<br>5<br>4  </p><h3 id="字符串的一般操作"><a href="#字符串的一般操作" class="headerlink" title="字符串的一般操作"></a>字符串的一般操作</h3><p>和数组一样，我们也可以使用下标访问、操作字符串的每一个字符：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line"><span class="keyword">int</span> length=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)</span><br><span class="line">    s[i]++;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,s);</span><br></pre></td></tr></table></figure><p>输入：<br>abcde<br>输出：<br>bcdef  </p><p>我们发现，字符串中的每一个字符，都通过访问下标的方式加一，最后整体输出。</p><h3 id="其它字符串函数"><a href="#其它字符串函数" class="headerlink" title="其它字符串函数"></a>其它字符串函数</h3><p>以上列出的是最常用的一些字符串函数，而string.h（C++中cstring）还提供更多字符串函数供使用。这里不作要求，只是简单列出，如在编写过程中有需要可以自行查询。  </p><ul><li>strcat(s1,s2):将参数s2字符串拷贝到参数s1字符串尾   </li><li>strlwr(s):将字符串中的大写字母转化为小写</li><li>strupr(s):将字符串中的小写字母转化为大写</li><li>strchr(s,c):在一个串中查找给定字符的第一个匹配之处</li><li>strrev(s):将一个字符串反向</li></ul><h1 id="C-风格的字符串"><a href="#C-风格的字符串" class="headerlink" title="C++风格的字符串"></a>C++风格的字符串</h1><p>C++除了支持使用C风格字符串和所有的C字符串函数外，还提供另一种“C++风格的字符串”。（与C风格的最大区别是，C++字符串是建立在面向对象的基础上的一个字符串类，属于C++的<strong>标准模板库</strong>（<strong>STL</strong>），除了提供更多操作和封装带来更好的稳定性外，字符串作为一个类型还可以与STL中的其他容器协同工作）  </p><h3 id="string类型"><a href="#string类型" class="headerlink" title="string类型"></a>string类型</h3><p>在学习<strong>面向对象编程</strong>的概念之前，我们只需知道，C++风格的字符串是C++内置的一种类型：<strong>string类型</strong>。<br>要使用string类型，我们首先要使用头文件string（不是C语言的string.h，也不是C++的cstring）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">string</span> s1,s2=<span class="string">"hello"</span>;</span><br></pre></td></tr></table></figure><p>这样，就简单完成了两个字符串s1,s2的定义，并给字符串s2赋了初值”hello”。我们发现：string类型是可以用字符串常量赋值的。  </p><h3 id="string操作"><a href="#string操作" class="headerlink" title="string操作"></a>string操作</h3><p>和C++的其他类型一样，string也可以使用cin/cout进行简单的输入输出：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br></pre></td></tr></table></figure><p>输入：<br>1234<br>输出：<br>1234   </p><p>string之间、string和字符串常量可以进行赋值：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1,s2=<span class="string">"hello"</span>;</span><br><span class="line">s1=s2;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">s1=<span class="string">"abc"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>hello<br>abc  </p><p>string类型提供一些简单的运算，简化了字符串处理的流程：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运算符有：</span><br><span class="line">+    += <span class="comment">//连接</span></span><br><span class="line">&gt;=   &lt;=   &gt;  &lt;  ==  !=  <span class="comment">//比较字典序</span></span><br></pre></td></tr></table></figure><p>如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"aaa"</span>,s2=<span class="string">"bbb"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1+s2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">s2+=s1;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>aaabbb<br>bbbaaa  </p><p>与C风格一样，string类型也可以通过下标访问每一个字符，<strong>下标从0开始</strong>：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s=<span class="string">"abcde"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)</span><br><span class="line">    s[i]++;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s;</span><br></pre></td></tr></table></figure><p>输出：<br>bcdef  </p><p>string还能以一个C风格字符串为初值，还可以转换成一个C风格字符串（这里的语法还没有涉及，不作要求，如有需要须强行记忆，可了解面向对象编程的<strong>构造函数</strong>、<strong>成员函数</strong>等知识）   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[<span class="number">10</span>]=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;<span class="comment">//将C风格的s1作为string s2构造函数的参数进行初始化</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s2;</span><br><span class="line">s2=<span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(s1,s2.c_str());<span class="comment">//调用s2的成员函数，返回一个C风格的字符串</span></span><br><span class="line"><span class="built_in">puts</span>(s1);</span><br></pre></td></tr></table></figure><p>输出：<br>abc<br>hello  </p><p>这样，我们可以通过两种字符串操作的转化实现按需求灵活使用。  </p><h3 id="string类型的成员函数"><a href="#string类型的成员函数" class="headerlink" title="string类型的成员函数"></a>string类型的成员函数</h3><p><strong>成员函数</strong>这个概念在学习面向对象编程之前还有再放一放，我们只需知道，string类型和C风格一样使用函数支持很多的字符串操作，只是并不是使用C语言中（也就是我们之前学过）的那种函数。<br>比如，类似于strlen函数，string类型则有：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1=<span class="string">"apple"</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1.length();</span><br></pre></td></tr></table></figure><p>输出：<br>5  </p><p>成员函数的调用方式如上。  </p><p>由于string类型的面向对象特性已超出本教程的范围，更多的string类型成员函数有余力可自行查询。  </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、什么是字符串，字符串和字符型数组有什么共同点？有什么区别？<br>2、C风格的字符串和C++风格的字符串有什么区别？<br>3、区分头文件string.h、cstring、string</p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、<a href="https://www.luogu.org/problemnew/show/P1914" target="_blank" rel="noopener">密码</a><br>2、<a href="https://www.luogu.org/problemnew/show/P1739" target="_blank" rel="noopener">表达式括号匹配</a><br>*3、实现一个能计算一位正整数+、-运算表达式的计算器<br>例：<br>输入：<br>1+3+2-5-7<br>输出：<br>-6<br>**4、实现一个能计算一位正整数+、-、*、/运算表达式的计算器<br>例：<br>输入：<br>1+3*5-4<br>输出：<br>12<br>***5、实现一个能计算正整数+、-、*、/运算表达式的计算器<br>例：<br>输入：<br>12+3*5-45<br>输出：<br>-18  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们经常需要使用计算机处理大量的字符，因而C/C++引入&lt;strong&gt;字符串&lt;/strong&gt;(string)以支持对大量字符操作。&lt;br&gt;其中，C++语言提供了&lt;strong&gt;C风格字符串&lt;/strong&gt;和&lt;strong&gt;C++风格字符串&lt;/strong&gt;（STL）两种选择：C风格的字符串操作与C语言完全一致，而C++风格的字符串则以面向对象的范式支持了更多操作。  &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】五、函数（2）</title>
    <link href="http://yoursite.com/2019/07/14/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%882%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/14/【小课堂】五、函数（2）/</id>
    <published>2019-07-14T12:21:47.000Z</published>
    <updated>2019-08-02T14:31:42.282Z</updated>
    
    <content type="html"><![CDATA[<h2 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h2><p>由于作用域是从声明开始的，所以在声明之前，一个名字是无法被使用的：</p><a id="more"></a>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处全局a未声明，不在作用域内，无法使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a;<span class="comment">//声明全局量a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处全局a已声明，在作用域内，可使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之类似的，一个函数也有作用域，一个函数名也只在它被声明之后才能使用：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a未声明，不在作用域内，无法调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如果函数f1中也需要调用函数a该怎么处理呢？显然，一种办法是更改声明顺序：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这里介绍另一种方法解决这一问题，我们引入一组之前一直混用的概念：<strong>声明</strong>（declaration）和<strong>定义</strong>（definition）  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;<span class="comment">//声明函数a</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;<span class="comment">//定义函数a</span></span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//此处函数a已声明，在作用域内，可调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明：我们让函数a先提前出现，扩大了定义域，但并不需给出具体的函数实现（需要有除函数体外的其它部分）<br>定义：真正实现函数a的功能，需要完整的函数信息（包括函数体）<br><strong>须注意，一个函数在代码中可以声明任意次，但只能定义一次；而声明过的函数如果没有完整定义也无法调用。</strong>  </p><p>类似的，对于变量其实也存在<strong>声明</strong>与<strong>定义</strong>之分（有时须借助extern关键字，这句话可跳过）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;<span class="comment">//声明变量a</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">4</span>;<span class="comment">//定义变量b，赋初值为4</span></span><br><span class="line"><span class="keyword">int</span> m[<span class="number">100</span>];<span class="comment">//声明数组m</span></span><br><span class="line"><span class="keyword">int</span> n[<span class="number">100</span>]=&#123;<span class="number">0</span>&#125;;<span class="comment">//定义数组n，并初始化</span></span><br></pre></td></tr></table></figure><p>其中的区别是：声明只是告诉编译器这个变量的出现，而定义则会为这个变量分配内存，此区别在使用数组时会更为明显——如果只是声明一个变量，却一直没有使用的话，在程序运行的过程中是不会消耗内存的。<br>虽然因为C/C++语言中写法区别不大，也是一些（不合格）程序员都容易混淆的概念，但确实是很有必要区分的；而在之后学习<strong>递归</strong>时会遇到的<strong>互调递归</strong>则更离不开声明、定义分离的写法。  </p><h2 id="递归（1）"><a href="#递归（1）" class="headerlink" title="递归（1）"></a>递归（1）</h2><p> <em>从前有座山，山上有座庙，庙里有个老和尚给小和尚讲故事，讲的是：从前有座山，山上有座庙，庙里有个老和尚给小和尚讲故事，讲的是：……</em><br>这段著名的神秘小故事，最迷人的部分就在于：老和尚讲的故事，就是它这个故事本身。<br>这种自我指涉的现象随处可见：树枝的分叉上还是分叉、分形曲线、汉诺塔……<br>类似地，C/C++的函数可以调用自身，我们把函数调用自身的操作称为<strong>递归</strong>，把调用了自身的函数称为<strong>递归函数</strong>。<br>然而，正如 <em>老和尚的故事</em> 一样，如果调用自身不加限制，便会无穷无尽循环下去（然而计算机空间并非无限，于是程序就会崩溃）。因此，递归也必须加以限制。  </p><p>考察以下阶乘定义：<br>$n! = n ×(n-1)!,n&gt;0$<br>$0! = 1$<br>第一行定义n的阶乘等于n乘以n-1的阶乘。发现在阶乘的定义中出现了阶乘本身，我们称阶乘是<strong>递归定义的</strong>。然而，n-1的阶乘又是多少呢？是n-1乘以n-2的阶乘……如果不加以控制，就必然会坠入负无穷，重演老和尚的悲剧。<br>因此，第二行，定义0的阶乘为1，这是其它所有自然数递归的终点，我们称之为<strong>递归的基本条件</strong>。<br>这样一来，所有自然数的阶乘都有了明确定义。我们可以以此为依据编写阶乘函数的另一种写法（第一种见例5.1）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//递归的基本条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> n * factorial(n<span class="number">-1</span>);<span class="comment">//递归求解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应上面的定义，发现代码的写法是完全一致的。但是在调用这个阶乘函数时，计算机内又发生了什么呢？（以下为重点，前方高能，请反复观察）<br><img src="https://www.z4a.net/images/2019/08/02/97015ab86aa887ce87b698d9011c78f0.png" alt="97015ab86aa887ce87b698d9011c78f0.png"><br>现在请反复观察这张深度好图（）<br>我们发现计算机执行方法和普通函数并无不同，遇到调用自身则视为调用了另一个函数（新建了另一个局部量n，原n不变），一直调用到factorial(0)，此时共有5个局部量n，值分别为4,3,2,1,0。到factorial(0)执行return语句，也是将值1代回到调用它的地方factorial(1)的return语句中，然后factorial(1)执行return语句……直到回到factorial(4)，计算得出factorial(4)=24，递归调用结束。  </p><p>递归是初学时相当难掌握的概念，极可能会出现一头雾水或自以为理解却并非正确的情况发生。我们现在需要先充分理解上面的阶乘一例，接下来再分析更多的递归程序进行归纳，之后再通过作业习题进行训练检验。毕竟，递归概念<strong>极其</strong>重要，是将来程序设计中不可避免使用的技术，也是衡量程序设计水平高下的重要标尺之一。<br>我们对递归这一节的要求是：  </p><ul><li>理解什么是递归</li><li>能读懂一段递归代码的含义</li><li>能分析出一个递归函数在计算机内部的执行过程</li><li>能正确计算出给定递归函数的返回值</li><li>能编写递归函数正确实现某一功能，不出现故障（<strong>bug</strong>）  </li></ul><p>下面继续我们的探险：  </p><h2 id="递归（2）"><a href="#递归（2）" class="headerlink" title="递归（2）"></a>递归（2）</h2><p>还有一种形式的递归：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">    a();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：此处的递归的基本条件未补全<br>这种函数自身未调用自身，但调用了调用自身的函数，也是一种特殊的递归，称为<strong>互调递归</strong>；由于C/C++作用域限制，需要先进行声明，先定义的函数才能调用后定义的函数。<br>下面是一个例子：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">even</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> odd(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">odd</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> even(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>even函数返回整数n是否为偶数，odd函数返回整数n是否为奇数。利用n与n-1奇偶性相反进行递推，0为偶数作为基本条件，即可实现。  </p><h2 id="对递归函数效率的思考"><a href="#对递归函数效率的思考" class="headerlink" title="对递归函数效率的思考"></a>对递归函数效率的思考</h2><p>考察以下斐波那契数列定义：<br>注：$fib(n)$表示斐波那契数列的第n项<br>$fib(n) = fib(n-1) + fib(n-2), n&gt;2$<br>$fib(1)=fib(2)=1$<br>fib的定义同样用到了自身，所以它也是递归定义的。因此我们也可以用递归的方法计算。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span> || n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在布置第一个任务：仿照上面分析阶乘函数图片的形式，试着分析调用函数fib(5)时的计算过程。<br><img src="https://www.z4a.net/images/2019/08/02/fib.png" alt="fib.png"><br>我们发现，计算fib(5)时调用了fib(4)和fib(3)；计算fib(4)时调用了fib(3)和fib(2)；计算fib(3)时调用了fib(2)和fib(1)；其中fib(3)被计算了2次，在fib(4)的左侧和fib(5)的右侧，fib(3)被反复计算。而随着n的增大，这张树形图将迅速增大。现在请尝试让你的计算机计算fib(45)的值，记录运算时间，并与之前你编写的循环结构求解斐波那契数列第45项的程序进行对比。（你想尝试更大的数可能要等很久很久）<br>循环结构求解斐波那契数列只执行45次，是瞬间即可得出结果；而递归求解却花了5秒（仔细观察发现递归求解斐波那契数列就是一个个1加出来的，运算量等于fib(n)，之后会知道此算法复杂度$O(2^n)$ ，为指数级），运算量差了许多数量级。<br>究其原因就是上面说的重复计算（称为<strong>冗余计算</strong>）大大浪费了算力；在递归求斐波那契数列的算法时出现的反复计算被称为<strong>重叠子问题</strong>。因此，在编写递归函数时，估算它的运算量也是必要的一个环节，而像上面的存在重叠子问题的递归算法则一定要警惕，并想办法优化，下面提供一种可行的优化方法供参考（此方法是解决递归时重复计算的常规方法：<strong>记忆化</strong>）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[n]!=<span class="number">0</span>)<span class="keyword">return</span> f[n];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        f[n]= fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fib(<span class="number">45</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此程序将递归过程中已经计算过的结果保存在f数组中（记忆化），重复调用时将直接返回结果，避免了重复计算，运算量也大大降低了。   </p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p>1、什么是声明？什么是定义？C/C++中为什么要区分这两者？<br>2、什么是递归？这种写法的好处是什么？可能的坏处是什么？<br>3、如何计算调用一个递归函数的执行次数？（即复杂度）  </p><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> func(n<span class="number">-2</span>)-func(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pj2014T2</span></span><br></pre></td></tr></table></figure><p>计算func(7)的值（不使用计算机）  </p><p>*2、</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">r</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">5</span>)<span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">        <span class="keyword">if</span>(r(n-i)&lt;<span class="number">0</span>)<span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tg2010T3</span></span><br></pre></td></tr></table></figure><p>计算r(16)的值（不使用计算机）<br>3、编程计算$Ackermann$函数$(m≤3)$，其中：<br>$Ackermann(m,n)=$<br>&emsp;&emsp;&emsp;&emsp;$n+1,(m=0)$<br>&emsp;&emsp;&emsp;&emsp;$Ackermann(m-1,n+1),(n=0)$<br>&emsp;&emsp;&emsp;&emsp;$Ackermann(m-1,Ackermann(m,n-1)),(m,n≠0)$<br>4、编写一个<strong>递归函数</strong>，传入一个正整数参数n，返回数列$a_n=2n+1$的前n项和<br>*5、编写一个<strong>递归过程</strong>，转入一个正整数参数、倒序输出其各数位的数字<br>要求主函数：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    func(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>123456<br>输出：<br>654321<br>**6、编写一个<strong>递归过程</strong>，传入一个正整数参数、输出其二进制形式   </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;声明与定义&quot;&gt;&lt;a href=&quot;#声明与定义&quot; class=&quot;headerlink&quot; title=&quot;声明与定义&quot;&gt;&lt;/a&gt;声明与定义&lt;/h2&gt;&lt;p&gt;由于作用域是从声明开始的，所以在声明之前，一个名字是无法被使用的：&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】五、函数（1）</title>
    <link href="http://yoursite.com/2019/07/11/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E4%BA%94%E3%80%81%E5%87%BD%E6%95%B0%EF%BC%881%EF%BC%89/"/>
    <id>http://yoursite.com/2019/07/11/【小课堂】五、函数（1）/</id>
    <published>2019-07-11T09:00:10.000Z</published>
    <updated>2019-08-03T16:48:42.691Z</updated>
    
    <content type="html"><![CDATA[<p><strong>函数</strong>是C/C++语言的核心概念，也是学习的重点所在。然而此函数与数学上的函数有所不同（也有称<strong>方法</strong>的），要理解掌握必须下些工夫。  </p><a id="more"></a><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>C/C++中的函数与C/C++语言的程序设计理念密切相关，在引入函数之前先看一个例子：<br><strong>例5.1：</strong><br>输入十个整数，输出他们的绝对值的阶乘  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,s;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;<span class="number">0</span>) x = -x;<span class="comment">//求x的绝对值</span></span><br><span class="line">        s = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;=x;j++)<span class="comment">//求x的阶乘</span></span><br><span class="line">            s *= j;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>1 -2 3 -4 5 -6 7 -8 9 -10<br>输出：<br>1 2 6 24 120 720 5040 40320 362880 3628800   </p><p>随着需求功能的增加，将各个功能写在一起的代码将变得不利阅读和修改；而如果能将代码模块化，就可以解决这一问题。C/C++语言为此引入<strong>函数</strong>。  </p><h2 id="定义一个函数"><a href="#定义一个函数" class="headerlink" title="定义一个函数"></a>定义一个函数</h2><p>函数是一个命名的语句序列，能够返回计算结果（称为返回值）。<br>函数的定义语法如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回值类型&gt; 函数名(&lt;参数类型<span class="number">1</span>&gt; 参数<span class="number">1</span>,&lt;参数类型<span class="number">2</span>&gt; 参数<span class="number">2</span>,……)&#123;</span><br><span class="line">    语句;</span><br><span class="line">    <span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以抽象为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;返回值类型&gt; 函数名(参数表)函数体</span><br></pre></td></tr></table></figure><p>这样，上面的例5.1就可以改写成（请先带着疑惑看完）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">absolute</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;<span class="number">0</span>)<span class="keyword">return</span> -x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=x;i++)</span><br><span class="line">        s *= i;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;factorial(absolute(x))&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，绝对值模块、阶乘模块被分开实现了，使用时只需调用即可，这样的编程设计思路（<strong>编程范式</strong>）更接近人类自然的解题思维。</p><p>下面将一一解释以上语法的每个部分。<br>以计算一个数的平方为例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一行：<br>定义一个名为square的函数，需要一个整型参数（并命名为x），返回一个整型返回值<br>第二行：<br>函数体部分为一个return语句，即返回值为表达式x * x的结果。  </p><p>需要注意的是，函数的定义是写在main函数外面的（可以观察例5.1的代码）。毕竟main也是函数，在C/C++代码中的地位与其它函数一样；更一般地、在C/C++语言中，一个函数不能定义在另一个函数内（暂不考虑lambda表达式）。  </p><h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><p>完成了函数的定义，我们就可以<strong>调用</strong>（diào）这个函数了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;square(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>6<br>输出：<br>36<br>6  </p><p>我们分析一下在调用过程中发生了什么：<br>程序从main函数开始执行，分别执行了int a;cin&gt;&gt;a;两行。<br>在执行cout&lt;&lt;square(a);时调用函数square，变量a作为被调用的参数。<br>于是，square函数中的变量x被赋值为变量a的值，并开始执行square函数：<br>返回x * x的值（即36），函数执行结束，<strong>回到调用的地方</strong>。<br>执行cout&lt;&lt;36;最后输出36。<br>操作后a的值没有改变。  </p><p>我们称调用时传递给函数的值（上例中的a）为<strong>实际参数</strong>（简称<strong>实参</strong>）；称接受该值的变量（上例中的x）为<strong>形式参数</strong>（简称<strong>形参</strong>）。<br>形参是函数中接受传入数值的特殊变量：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    x++;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add1(a)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>6<br>输出：<br>7<br>6<br>函数调用过程中，a的值被赋给了形参x，x在函数中+1并返回；而a的值仍为6：操作后a的值没有改变。  </p><p>试试看在main函数中为上例的x赋值，或者输出x，看看会发生什么——</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>考察以下代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x*x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;x;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会告诉你，这个代码是错误的：x没有定义。square函数中定义了变量x，到main函数中却没有了，因为main函数超出了变量x的<strong>作用域</strong>。  </p><p>要解释作用域这一概念，我认为最好的类比就是数学题中出现的前提条件：<br>19.已知函数$f(x)=x^2,g(x)$<br>(1)若$g(x)=2^x$，设$h(x)=…$……<br>(2)……<br>发现:<br>总条件是$f(x)=x^2$，在整道题中不会改变，且都能使用<br>第一小问中：$g(x)=2^x$，但只能在第一问中使用；另定义了$h(x)$<br>第二小问中：没有关于$g(x)$的条件，因此它可以为任意函数，$h(x)$甚至没有出现，自然无法使用。  </p><p>与之类比，C/C++有<strong>全局量</strong>与<strong>局部量</strong>的概念，定义在<strong>所有</strong>函数外的变量为全局量，作用域为从声明变量开始，到代码的末尾；而定义在函数内的变量为局部量（包括形参也是特殊的局部量），作用域仅在该函数内。因此，上例中的main函数无法使用square中的x。<br>全局量和局部量可以同名，但同一作用域不能出现两个同名全局量或局部量，请看下例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add1(<span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;add1(x)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>11<br>21  </p><p>我们先在所有函数外定义了一个变量x，所以这个x为全局量；然后定义了一个函数add1，参数表中也声明了一个变量x作为形式参数，而这个x在函数内，故为局部量，作用域仅在add1函数内；<br>程序从main函数开始运行：<br>先将x赋值为20：此时main函数中没有x的定义，因此这个x是指全局量x（全局量x赋值为20）。<br>调用add1(10)：局部量x（形参）被赋值为10，执行add1函数，return x+1;那么这个x是10（局部量）还是20（全局量）呢？输出结果告诉我们，此处的x是函数内的局部量——一般地，如果有同名的局部量和全局量，那个变量名将会优先定向到局部量，只有没有这个局部量时，它才代指那个全局量。<br>调用add1(x)：此时的x是局部量，因此值为20，并传给形参x，最后返回21。  </p><p>C/C++的这一特性保证了函数是一个安全的小环境，在里面定义、使用任何名字都不用担心与外面的代码冲突，也让我们能够在定义多个函数时放心的使用诸如x等一些简单的名字而不冲突。</p><h2 id="return语句"><a href="#return语句" class="headerlink" title="return语句"></a>return语句</h2><p>return语句控制着函数的返回值，写在函数体中，语法为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> 返回值;</span><br></pre></td></tr></table></figure><p>因此，return后的返回值类型必须与函数定义时写的类型一致。  </p><p>同时，return语句也控制着函数的退出，函数体执行到return语句就会立即退出，<strong>销毁所有局部量</strong>（包括形参和在函数体内定义的局部量），并将return后的返回值代回调用处：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+<span class="number">1</span>;</span><br><span class="line">    t++;</span><br><span class="line">    <span class="keyword">return</span> t+<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面函数f将返回t+1，而后面的语句将永远不会执行。  </p><h2 id="无返回值函数（过程）"><a href="#无返回值函数（过程）" class="headerlink" title="无返回值函数（过程）"></a>无返回值函数（过程）</h2><p>特别地，一个C/C++函数也可以没有返回值，在定义函数时返回值类型为void（空类型），如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，函数也可以没有参数，即参数为void（也可以省略）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g1</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了，一个没有返回值的函数有什么用呢？  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scan_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tadd</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    t+=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_t</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">scan_t</span>();</span><br><span class="line">    tadd(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">print_t</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    execute();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入：<br>9<br>输出：<br>14</p><p>而如例4.5，就可以写成：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printline</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"*"</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">       printline(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，无返回值函数仍然能实现一段有功用的代码，这也使得代码模块化了，因而无返回值函数也被称为<strong>过程</strong>（procedure）。因为没有返回值，一个过程中可以在任何地方使用return语句退出，但禁止return语句后带返回值。然而限于目前工具有限，我们目前仅能够通过全局量让过程修改一个变量，给代码的其他部分使用；在学习了<strong>指针</strong>、<strong>引用</strong>后，过程将能够发挥更大作用。  </p><p>我们发现，main函数就是一个无参数（也可以有参数）、返回值为int（正常运行是返回0）的函数。</p><h1 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h1><h3 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h3><p>1、什么是C/C++函数，它与数学中的函数有什么不同？<br>2、我们为什么要引入函数？使用函数编程有什么好处？<br>3、什么是形参？什么是实参？C/C++语言函数为什么需要形参？<br>4、什么是作用域？为什么要引入作用域？<br>5、执行一句return语句会发生哪些事情？<br>6、什么是过程？  </p><h3 id="习题："><a href="#习题：" class="headerlink" title="习题："></a>习题：</h3><p>（以下习题，除main外应至少编写一个函数实现）<br>1、输入整数n，输出$[2,n]$中的所有质数<br>2、输入整数n，输出$[2,n]$中所有回文质数<br>3、计算组合数$C^m_n$的值<br>4、输入整数n，和n个整数，输入两个整数i，j，将位置i到j间的数升序排列，其余不变<br>例：<br>输入：<br>5<br>3 5 2 8 6<br>2 4<br>输出：<br>3 2 5 8 6<br>*5、输入十进制正整数n，转化二进制输出</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;函数&lt;/strong&gt;是C/C++语言的核心概念，也是学习的重点所在。然而此函数与数学上的函数有所不同（也有称&lt;strong&gt;方法&lt;/strong&gt;的），要理解掌握必须下些工夫。  &lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【小课堂】四点五、一些支线任务</title>
    <link href="http://yoursite.com/2019/07/10/%E3%80%90%E5%B0%8F%E8%AF%BE%E5%A0%82%E3%80%91%E5%9B%9B%E7%82%B9%E4%BA%94%E3%80%81%E4%B8%80%E4%BA%9B%E6%94%AF%E7%BA%BF%E4%BB%BB%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/07/10/【小课堂】四点五、一些支线任务/</id>
    <published>2019-07-10T05:50:25.000Z</published>
    <updated>2019-08-01T16:28:38.821Z</updated>
    
    <content type="html"><![CDATA[<p>小课堂的基础篇即将过半，下半场的难度则将更上一个台阶。而在主线学习的过程中，C/C++语言还有许多细枝末节的技术知识，因此借此“中场休息”时间，本课介绍一些之前中没有涉及的“支线任务”，有些内容有些深奥，跳过不影响后续主线的学习，可视情况阅读。</p><a id="more"></a><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>（其实在之前的教程中就已经出现过）<br>注释是写在代码中给自己或其他程序员看的文字。注释方法有两种：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是单行的注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">如果需要跨行写注释</span></span><br><span class="line"><span class="comment">可以像这样框起来</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注释文字在程序中不起任何作用，编译器将忽略所有注释。但注释对一段良好的代码是<strong>必需</strong>的。随着代码逐渐复杂，将很难一眼看懂其功能，边编写边写注释可以大大提高维护代码时的工作效率。  </p><p>注释的另一大功能是在测试代码时对语句进行临时的保留/删除，如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">    a = (b + <span class="number">2</span>) * i;</span><br><span class="line">    <span class="comment">//a = (b + 2) / i;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用注释可以快速使不想执行的代码暂时“封印”，如以后需要，只需将注释符删去，代码就恢复了功能。  </p><hr><h1 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h1><p>虽然长得不太像，sizeof的确是C/C++运算符之一，用于计算数值/表达式/类型的空间大小（字节数），如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="number">1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">double</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>4<br>8<br>表示整型数1占4个字节，一个double型数据占8个字节。<br>如果需要估算开一个数组的开销，就可以这样计算：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> a[<span class="number">10000</span>][<span class="number">5000</span>]</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*<span class="number">10000</span>*<span class="number">5000</span>/<span class="number">1024</span>/<span class="number">1024</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>381<br>所以，使用一个10000*5000的double型数组的开销约为381MiB  </p><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>在介绍位运算之前首先要简单引入现代计算机中的数字编码知识。<br>我们知道，数字在计算机中是以二进制存储的（不仅是历史原因，和二分、倍增、二叉等算法数据结构也有微妙的联系）。二进制的概念不再详细介绍，有需要可自行搜索。<br>位运算就是C/C++对于二进制数的操作，由于与计算机底层架构一致，效率一般比常规的运算符快上不少。<br>位运算符有：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&amp;    <span class="comment">//按位与</span></span><br><span class="line">|    <span class="comment">//按位或</span></span><br><span class="line">~    <span class="comment">//按位非</span></span><br><span class="line">^    <span class="comment">//按位异或</span></span><br><span class="line">&lt;&lt;   <span class="comment">//左移</span></span><br><span class="line">&gt;&gt;   <span class="comment">//右移</span></span><br></pre></td></tr></table></figure><p>我们拿int a = 42;（二进制101010）int b = 23;（二进制1 0111）为例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">42</span>, b = <span class="number">23</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a &amp; b) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a | b) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (~a) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a ^ b) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a &lt;&lt; <span class="number">2</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; (a &gt;&gt; <span class="number">2</span>) &lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<br>2<br>63<br>-43<br>61<br>168<br>10  </p><p>按位与：将两个二进制数每一位进行与运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line"> &amp; <span class="number">0001</span> <span class="number">0111</span></span><br><span class="line">--------------</span><br><span class="line">   <span class="number">0000</span> <span class="number">0010</span>  （=十进制<span class="number">2</span>）</span><br></pre></td></tr></table></figure><p>按位或：同理，将两个二进制数每一位进行或运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line"> | <span class="number">0001</span> <span class="number">0111</span></span><br><span class="line">--------------</span><br><span class="line">   <span class="number">0011</span> <span class="number">1111</span>  （=十进制<span class="number">63</span>）</span><br></pre></td></tr></table></figure><p>按位非：将<strong>一个</strong>二进制数每一位进行非运算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> ~ <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line">--------------</span><br><span class="line">   <span class="number">1101</span> <span class="number">0101</span>  （=一个补码为<span class="number">11010101</span>的数，即十进制<span class="number">-43</span>）</span><br></pre></td></tr></table></figure><p>此处有疑问可跳过，或自行了解详细的数字编码介绍（原码、反码、补码） </p><p>按位异或：将两个二进制数每一位进行异或运算<br>异或（xor）是和与或非类似的逻辑运算，真值表如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a    b    a xor b</span><br><span class="line"><span class="number">1</span>    <span class="number">1</span>      <span class="number">0</span></span><br><span class="line"><span class="number">0</span>    <span class="number">0</span>      <span class="number">0</span></span><br><span class="line"><span class="number">1</span>    <span class="number">0</span>      <span class="number">1</span></span><br><span class="line"><span class="number">0</span>    <span class="number">1</span>      <span class="number">1</span></span><br></pre></td></tr></table></figure><p>即两个布尔量相同时为false，不同时为true<br>所以，按位异或也是如此：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line"> ^ <span class="number">0001</span> <span class="number">0111</span></span><br><span class="line">--------------</span><br><span class="line">   <span class="number">0011</span> <span class="number">1101</span>  （=十进制<span class="number">61</span>）</span><br></pre></td></tr></table></figure><p>左移/右移：左边是一个二进制，右边是要移动的位数  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line"> &lt;&lt;         <span class="number">2</span>  （每一位都往左移动了两位，最后两位用<span class="number">0</span>填充）</span><br><span class="line">--------------</span><br><span class="line">    <span class="number">1010</span> <span class="number">1000</span>  （=十进制<span class="number">168</span>）</span><br><span class="line"></span><br><span class="line">    <span class="number">0010</span> <span class="number">1010</span></span><br><span class="line"> &gt;&gt;         <span class="number">2</span>  （每一位都往右移动了两位，最后两位舍去了）</span><br><span class="line">--------------</span><br><span class="line">    <span class="number">0000</span> <span class="number">1010</span>  （=十进制<span class="number">10</span>）</span><br></pre></td></tr></table></figure><p>位运算在数学中较少出现，但在程序编写中有许多意想不到的功能，用得好则可以大大提高运行效率。这里简单介绍几种用法，更多用途可以自行探索。  </p><p> <em>我们发现，左、右移操作就是在二进制数末尾添0/去除位数的操作。类比十进制数添n个0 == $*10^n$ ，对照上例，a&lt;&lt;n即 $a*2^n$ 、a&gt;&gt;n即 $a/2^n$（向下取整）</em>  </p><h1 id="一些其他的数据类型"><a href="#一些其他的数据类型" class="headerlink" title="一些其他的数据类型"></a>一些其他的数据类型</h1><p>除了之前介绍过的数据类型外，C/C++语言还提供更多的内置类型，这里也只是简单介绍：  </p><h2 id="类型修饰符"><a href="#类型修饰符" class="headerlink" title="类型修饰符"></a>类型修饰符</h2><p>C/C++提供类型修饰符对基础的类型进行修饰，以适应不同的应用。<br>修饰符有：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">short</span></span><br></pre></td></tr></table></figure><p>它们可置于char、int、double类型前，改变数据类型，如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> a;<span class="comment">//-32768 到 32767</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b;<span class="comment">//0 到 4294967295</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> c;<span class="comment">//0 到 65535</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> d;<span class="comment">//16 个字节</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e;<span class="comment">//0 到 255</span></span><br></pre></td></tr></table></figure><p>另外，C/C++语言还提供指针、自定义类型，都是C/C++类型系统的一部分：<br>C中有：指针、枚举、联合体、结构体<br>C++中有：指针、<strong>引用</strong>、枚举、联合体、结构体、<strong>类</strong>、还有<strong>模板</strong>提供泛型甚至元编程的支持。  </p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>C/C++还提供typedef保留字为数据类型起别名，以增加代码的可读性，如：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> month;</span><br><span class="line">month a,b;</span><br><span class="line">a=<span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>此时变量a的类型仍是int，但可以用month进行定义。  </p><h1 id="switch语句"><a href="#switch语句" class="headerlink" title="switch语句"></a>switch语句</h1><p>与if类似，switch语句是C/C++提供的另一种分支结构语法:  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">1</span>: </span><br><span class="line">        语句<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">case</span> 常量<span class="number">2</span>: </span><br><span class="line">        语句<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> 常量n: </span><br><span class="line">        语句n;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//可选</span></span><br><span class="line">    <span class="keyword">default</span>: </span><br><span class="line">        语句n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> choice;</span><br><span class="line"><span class="keyword">int</span> score;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;choice;</span><br><span class="line"><span class="keyword">switch</span>(choice)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">        score = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">        score = <span class="number">80</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">        score = <span class="number">70</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        score = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;score;</span><br></pre></td></tr></table></figure><p>即：选A得100分、选B得80分、选C的70分，其他选项不得分。</p><p>其中的变量须是整型、字符型或枚举型，满足条件即会进入对应的case语句，执行其中的语句。须注意：break语句为可选，如果删除则执行完case中的语句后将不会退出switch语句，而是执行下面的case语句，可自行验证。  </p><p>switch语句的功能与对应的if-else语句等价，虽然switch语句语法略复杂，但在效率上switch语句会略优于if-else语句，也有更好的可读性和可维护性。因此，可以视使用场合灵活运用两种分支语句。  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小课堂的基础篇即将过半，下半场的难度则将更上一个台阶。而在主线学习的过程中，C/C++语言还有许多细枝末节的技术知识，因此借此“中场休息”时间，本课介绍一些之前中没有涉及的“支线任务”，有些内容有些深奥，跳过不影响后续主线的学习，可视情况阅读。&lt;/p&gt;
    
    </summary>
    
      <category term="小课堂" scheme="http://yoursite.com/categories/%E5%B0%8F%E8%AF%BE%E5%A0%82/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【NOIP2018】NOIP2018游记</title>
    <link href="http://yoursite.com/2018/11/11/%E3%80%90NOIP2018%E3%80%91NOIP2018%E6%B8%B8%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/11/11/【NOIP2018】NOIP2018游记/</id>
    <published>2018-11-11T13:44:08.000Z</published>
    <updated>2019-08-02T07:10:14.896Z</updated>
    
    <content type="html"><![CDATA[<p>NOIP2018退役赛。脑中想象过无数次的长篇退役文也没时间写了，就简单记录一下。</p><a id="more"></a><hr><h2 id="Day0"><a href="#Day0" class="headerlink" title="Day0"></a>Day0</h2><p>刚考完期中考，周五还要上课，十分疲惫。还是背了一天板子，虽然这一年又学了很多，准备却很不充分。重点看了些基础算法。</p><h2 id="Day1"><a href="#Day1" class="headerlink" title="Day1"></a>Day1</h2><p>一大早就到了华二，7:30左右，天气晴好。发现数论很虚在车上狂看数论。<br>考场在三楼机房二，同考场还有朱先生韩先生和flx佬。位子在最后一排靠墙，很安静干扰少。按惯例考前30分钟应当是能试机的，却被监考很强硬的制止了，让我怀疑是不是被针对了（<br>解压密码也不好好报，解了好几次，绝了（  </p><h4 id="开考"><a href="#开考" class="headerlink" title="开考"></a>开考</h4><p>T1<br>真的没见过，考后才知道是原题……一开始看到区间就方了还以为是区间dp，毕竟就在前一次模拟赛就做过一个题目描述很接近的石子涂颜色区间dp。后来简单推了一下没找到贪心的反例，就直接模拟每次找最长区间贪心了。还调了优先队列优化。<br>事后和flx对了下说是分治才发现我手动用队列模拟了递归过程……<br><strong>期望得分：80到100<br>洛谷自测：100</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">100005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> st,ed,l,mi;</span><br><span class="line">    node(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c,<span class="keyword">int</span> d)&#123;</span><br><span class="line">        st=a;</span><br><span class="line">        ed=b;</span><br><span class="line">        l=c;</span><br><span class="line">        mi=d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node s)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.l&gt;l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="keyword">int</span> a[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> mi=MAXN;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;mi)mi=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">node <span class="title">now</span><span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">    q.push(node(<span class="number">1</span>,n,n,mi));</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>,tst;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        now=q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span>(now.l==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">        ans+=now.mi;</span><br><span class="line">        mi=MAXN;</span><br><span class="line">        tst=now.st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=now.st;i&lt;=now.ed;i++)&#123;</span><br><span class="line">            a[i]-=now.mi;</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=<span class="number">0</span>&amp;&amp;mi&gt;a[i])mi=a[i];</span><br><span class="line">            <span class="keyword">if</span>(a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                q.push(node(tst,i<span class="number">-1</span>,i-tst,mi));</span><br><span class="line">                tst=i+<span class="number">1</span>;</span><br><span class="line">                mi=MAXN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.push(node(tst,now.ed,now.ed-tst+<span class="number">1</span>,mi));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T2<br>读题读到一半就慌了：这不是去年T1的升级版，大凯的疑惑嘛……<br>大概只要参加过去年比赛的思路都会被这么带偏罢（<br>开始我还照这个思路想着（带着对数论的恐惧……），各种gcd……突然发现实际是求：如果能用其它面额表示一种，这种就可以删去。而这题就是之前模拟赛的原题了，我清晰地记得ywd说过是个背包（完全背包），然后我对dp有阴影，最后选择了搜索，并加了个记忆化。<br>但我根本不能确定这记忆化的正确性，这导致了我做完后化了半个小时对拍（对拍程序还写错了、哭）最终赌了一把交了记忆化了版本。<br><strong>期望得分：100或0（哭了）<br>洛谷自测：100</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">bool</span> f;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> dp[<span class="number">25005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f||dp[v])<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(!vis[i]&amp;&amp;v&gt;=a[i])&#123;</span><br><span class="line">            <span class="keyword">if</span>(v-a[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                f=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dfs(v-a[i]);</span><br><span class="line">                dp[v-a[i]]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=t;k++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">int</span> ans=n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="keyword">sizeof</span>(dp));</span><br><span class="line">            f=<span class="number">0</span>;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            dfs(a[i]);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(f)ans--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T3<br>这是D1的败笔了，可能也是缺乏比赛经验罢，面对如此详尽的数据约定竟不知道如何骗分……<br>一开始想的是算出任意两点的最短路，再从长到短贪。再仔细一看题发现是明显错误的(<br>于是先暴力了个Floyd（第一次还没打对），骗m==1的情况。<br>然后就不知道了……连暴力都不会打，又想了个办法记录每条最短路的编号，又是队列又是向量的，反正乱搞一通后删光了。只留了个Floyd……<br><strong>期望得分：5或10<br>洛谷自测：10</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">20000000</span>;</span><br><span class="line"><span class="keyword">int</span> g[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b,w,ma=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                g[i][j]=INF;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">            g[a][b]=w;</span><br><span class="line">            g[b][a]=w;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(g[i][j]&gt;g[i][k]+g[k][j])</span><br><span class="line">                        g[i][j]=g[i][k]+g[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">                <span class="keyword">if</span>(ma&lt;g[i][j])ma=g[i][j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,ma);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Day2"><a href="#Day2" class="headerlink" title="Day2"></a>Day2</h2><p>D2就全线爆炸了。最大的问题还是心理素质不过关吧。有几重因素干扰实力发挥就马上受影响了……先是因为进博会调休，D2比完还要上课的，而考场就在比赛的时候上课，机房的铃声又没关，甚至还有播通知的，绝了。题目难度和D1也不是一个层次，其实做到一半就耳赤了。  </p><p>T1<br>刚读完题，就蒙了：这不就是个裸的深搜吗？？样例2也没仔细看，直接就打了，深搜还卡了一下……30分钟后，和大样例4一对，我发现事情没那么简单……再看了数据说明有数了：对无环图裸深搜，得60分<br>那有环怎么办呢？我想的是先找环再在搜的时候“反悔”。然而在得60分后我选择了做后面两题，等我灰头土脸回来后发现连环都不会找了，先打上并查集……然后删掉……再打上tarjan……然后删掉……<br>最终也没有成功，交了个裸搜。<br><strong>期望得分：60<br>洛谷自测：60</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">bool</span> g[<span class="number">5005</span>][<span class="number">5005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">5005</span>]=&#123;<span class="number">0</span>&#125;,f;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>,pa[<span class="number">5005</span>];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,pa[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        <span class="keyword">if</span>(g[i][j]&amp;&amp;!vis[j])&#123;</span><br><span class="line">            vis[j]=<span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            pa[cnt]=j;</span><br><span class="line">            <span class="keyword">if</span>(cnt==n)&#123;</span><br><span class="line">                pr();</span><br><span class="line">                f=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dfs(j);</span><br><span class="line">            vis[j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a][b]=<span class="number">1</span>;</span><br><span class="line">        g[b][a]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vis[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    pa[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    cnt=<span class="number">1</span>;</span><br><span class="line">    f=<span class="number">0</span>;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T2<br>看完题就崩了，首先题面就不友好，花了些时间理解，看到mod后明白是数学题，心里凉了半截。<br>数据范围也很迷，小于8的数据似乎在暗示打表（<br>我就带着打表的觉悟搜起来。可是搜也写不对（心态已经崩了），不管怎样搜出来所有状态都是合法的……<br>最后手算了&lt;=3的情况（还算错了）<br>唯一稍微开心些的是在考场上想了个生成01矩阵的方法（然而并没有什么卵用……）：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//大概是</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;<span class="built_in">pow</span>(<span class="number">2</span>,n*m);k++)&#123;</span><br><span class="line">    seed=k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            g[i][j]=seed&amp;<span class="number">1</span>;</span><br><span class="line">            seed&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>期望得分：0到20（悲）<br>洛谷自测：5</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;m==<span class="number">3</span>||n==<span class="number">3</span>&amp;&amp;m==<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"54"</span>);<span class="comment">//是错的</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>&amp;&amp;m==<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">"12"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>&amp;&amp;m==<span class="number">3</span>)<span class="built_in">printf</span>(<span class="string">"112"</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">5</span>&amp;&amp;m==<span class="number">5</span>)<span class="built_in">printf</span>(<span class="string">"7xxx"</span>);<span class="comment">//忘了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>T3<br>心态已经爆炸，看着对骗分这么友好的数据一点都不会骗。<br>先瞄准了A组数据，一条链的情况。我想这应该是个dp，但是dp实在写不出很清晰的思路，最后糊了一个上去……<br><strong>期望得分：0（别说了）<br>洛谷自测：0（别说了）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">2005</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fm</span><span class="params">(<span class="keyword">int</span> st,<span class="keyword">int</span> ed)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> min(dp[st][ed],dp[st][ed<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s);</span><br><span class="line">    <span class="keyword">int</span> a,b,x,y;</span><br><span class="line">    <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">'A'</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            dp[i][i+<span class="number">1</span>]=w[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">2</span>;j&lt;=n;j++)</span><br><span class="line">                dp[i][j]=min(dp[i][j<span class="number">-1</span>],dp[i][j<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d%d"</span>,&amp;a,&amp;b,&amp;x,&amp;y);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">abs</span>(a-b)==<span class="number">1</span>&amp;&amp;x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,fm(<span class="number">0</span>,a)+fm(a,n));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">1</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,fm(<span class="number">0</span>,b)+fm(b,n));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d"</span>,fm(<span class="number">0</span>,n));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d"</span>,fm(<span class="number">0</span>,a)+fm(a,b)+fm(b,n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NOIP2018退役赛。脑中想象过无数次的长篇退役文也没时间写了，就简单记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yoursite.com/categories/OI/"/>
    
    
      <category term="OI" scheme="http://yoursite.com/tags/OI/"/>
    
      <category term="OI游记" scheme="http://yoursite.com/tags/OI%E6%B8%B8%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>【动态规划】树形DP</title>
    <link href="http://yoursite.com/2018/11/06/%E3%80%90%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91%E6%A0%91%E5%BD%A2DP/"/>
    <id>http://yoursite.com/2018/11/06/【动态规划】树形DP/</id>
    <published>2018-11-06T06:37:15.000Z</published>
    <updated>2019-08-02T05:07:32.297Z</updated>
    
    <content type="html"><![CDATA[<p>树形DP是一种特殊的DP，利用树形结构的无环、分层、有很好的递归性质的特点，进行状态转移。常用dfs整棵树+记忆化的方式实现。</p><a id="more"></a><hr><p>以下是几道难度递进的例题：</p><h1 id="P2015二叉苹果树"><a href="#P2015二叉苹果树" class="headerlink" title="P2015二叉苹果树"></a>P2015二叉苹果树</h1><p>由于限制了二叉，约束条件就很简明了：  </p><p>f[i][j]=max{f[左][k]+f[右][j-k-1]+a[i]}(0&lt;=k&lt;=j-1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> e[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,r[<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;,w[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">105</span>][<span class="number">105</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(e[v][i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            l[v]=i;</span><br><span class="line">            w[i]=e[v][i];</span><br><span class="line">            e[v][i]=<span class="number">-1</span>;</span><br><span class="line">            e[i][v]=<span class="number">-1</span>;</span><br><span class="line">            build(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(e[v][i]&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            r[v]=i;</span><br><span class="line">            w[i]=e[v][i];</span><br><span class="line">            e[v][i]=<span class="number">-1</span>;</span><br><span class="line">            e[i][v]=<span class="number">-1</span>;</span><br><span class="line">            build(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(l[i]==<span class="number">0</span>&amp;&amp;r[i]==<span class="number">0</span>)<span class="keyword">return</span> w[i];</span><br><span class="line">    <span class="keyword">if</span>(f[i][j]!=<span class="number">0</span>)<span class="keyword">return</span> f[i][j];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;=j<span class="number">-1</span>;k++)</span><br><span class="line">        f[i][j]=max(f[i][j],dp(l[i],k)+dp(r[i],j-k<span class="number">-1</span>)+w[i]);</span><br><span class="line">    <span class="keyword">return</span> f[i][j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">int</span> a,b,c;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            e[i][j]=<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[a][b]=c;</span><br><span class="line">        e[b][a]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    build(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp(<span class="number">1</span>,q+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P2014选课"><a href="#P2014选课" class="headerlink" title="P2014选课"></a>P2014选课</h1><p>与上一题不同的是节点的子节点数没有限制了，增加了一个循环，于是也增加了一个维度。转移方程类似背包，不同点就是如果选子节点，父节点一定要选。</p><p>设$f_{i,j,k}$为编号为$i$的节点直到第$j$个子节点（第0个为节点$i$本身），取$k$个的最大值<br>$f_{i,j,k}=max(f_{i,j-1,k},f_{i,j-1,k-t}+f_{ison,s[ison],t}),0&lt;=t&lt;=k-1$</p><p>其中$s[i]$为节点$i$的子节点数</p><p>$f_{i,j,0}=0$（不选）$f_{i,0,k}=w[i]$（节点本身）</p><p>其中必须选根节点的限制体现在最后一维的循环中的-1上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">305</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> w[MAXN]=&#123;<span class="number">0</span>&#125;,s[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[a][b][c]!=<span class="number">-1</span>)<span class="keyword">return</span> f[a][b][c];</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;f[a][b][c]=<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        f[a][b][c]=w[a];</span><br><span class="line">        <span class="keyword">return</span> f[a][b][c];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f[a][b][c]=dp(a,<span class="number">0</span>,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=c<span class="number">-1</span>;j++)</span><br><span class="line">        f[a][b][c]=max(f[a][b][c],</span><br><span class="line">        dp(a,b<span class="number">-1</span>,c-j)+dp(g[a][b<span class="number">-1</span>],s[g[a][b<span class="number">-1</span>]],j));</span><br><span class="line">    <span class="keyword">return</span> f[a][b][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a,&amp;b);</span><br><span class="line">        g[a].push_back(i);</span><br><span class="line">        s[a]++;</span><br><span class="line">        w[i]=b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp(<span class="number">0</span>,s[<span class="number">0</span>],m+<span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="P2515软件安装"><a href="#P2515软件安装" class="headerlink" title="P2515软件安装"></a>P2515软件安装</h1><p>一开始以为这题和上一题一样，是直接多叉树背包，只是把限制条件节点数改成了花费。然而后来发现图可能有环，这使此题又上了一个难度。<br>先使用tarjan缩点，一个连通分量中只能全选。这样将图化成一个无环的森林，再将每棵树的根连到超级根节点0，最后在新图树上背包得到答案。</p><p>其中必须选根节点的限制体现在最后一维的循环中的-w[i]上</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN=<span class="number">105</span>,MAXM=<span class="number">505</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; g[MAXN],g2[MAXN];</span><br><span class="line"><span class="keyword">int</span> v[MAXN]=&#123;<span class="number">0</span>&#125;,w[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> s[MAXN]=&#123;<span class="number">0</span>&#125;,s2[MAXN]=&#123;<span class="number">0</span>&#125;,</span><br><span class="line">dfn[MAXN]=&#123;<span class="number">0</span>&#125;,low[MAXN]=&#123;<span class="number">0</span>&#125;,indx=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> color[MAXN]=&#123;<span class="number">0</span>&#125;,cnt[MAXN]=&#123;<span class="number">0</span>&#125;,sum=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="keyword">bool</span> vis[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=++indx;</span><br><span class="line">    low[u]=indx;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    st.push(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s[u];i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=g[u][i];</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        color[u]=++sum;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(st.top()!=u)&#123;</span><br><span class="line">            color[st.top()]=sum;</span><br><span class="line">            vis[st.top()]=<span class="number">0</span>;</span><br><span class="line">            st.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        st.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> he[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> del[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> ze[MAXN]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trans</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(dfn[i]==<span class="number">0</span>)tarjan(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;s[i];j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=g[i][j];</span><br><span class="line">            <span class="keyword">if</span>(he[color[i]]==<span class="number">0</span>||he[color[i]]==i)</span><br><span class="line">                he[color[i]]=i;</span><br><span class="line">            <span class="keyword">else</span> del[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(color[t]==color[i])&#123;</span><br><span class="line">                <span class="keyword">if</span>(del[i])&#123;</span><br><span class="line">                    w[he[color[i]]]+=w[i];</span><br><span class="line">                    v[he[color[i]]]+=v[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                g2[he[color[i]]].push_back(t);</span><br><span class="line">                s2[he[color[i]]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cnt[color[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&gt;<span class="number">1</span>&amp;&amp;!vis[he[i]])&#123;</span><br><span class="line">            vis[he[i]]=<span class="number">1</span>;</span><br><span class="line">            g2[<span class="number">0</span>].push_back(he[i]);</span><br><span class="line">            s2[<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(ze[i]&amp;&amp;!vis[he[color[i]]])&#123;</span><br><span class="line">            vis[he[color[i]]]=<span class="number">1</span>;</span><br><span class="line">            g2[<span class="number">0</span>].push_back(i);</span><br><span class="line">            s2[<span class="number">0</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAXN][MAXN][MAXM]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b,<span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(del[a])<span class="keyword">return</span> dp(he[color[a]],b,c);</span><br><span class="line">    <span class="keyword">if</span>(f[a][b][c]!=<span class="number">-1</span>)<span class="keyword">return</span> f[a][b][c];</span><br><span class="line">    <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;f[a][b][c]=<span class="number">0</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(c&gt;=w[a])f[a][b][c]=v[a];</span><br><span class="line">        <span class="keyword">else</span> f[a][b][c]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> f[a][b][c];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    f[a][b][c]=dp(a,<span class="number">0</span>,c);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=c-w[a];j++)</span><br><span class="line">        f[a][b][c]=max(f[a][b][c],</span><br><span class="line">        dp(a,b<span class="number">-1</span>,c-j)+dp(g2[a][b<span class="number">-1</span>],s2[g2[a][b<span class="number">-1</span>]],j));</span><br><span class="line">    <span class="keyword">return</span> f[a][b][c];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="keyword">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;w[i]);</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;v[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a);</span><br><span class="line">        <span class="keyword">if</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">            g[a].push_back(i);</span><br><span class="line">            s[a]++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ze[i]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    trans();<span class="comment">//缩点</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dp(<span class="number">0</span>,s2[<span class="number">0</span>],m));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;树形DP是一种特殊的DP，利用树形结构的无环、分层、有很好的递归性质的特点，进行状态转移。常用dfs整棵树+记忆化的方式实现。&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yoursite.com/categories/OI/"/>
    
    
      <category term="OI" scheme="http://yoursite.com/tags/OI/"/>
    
      <category term="动态规划" scheme="http://yoursite.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
      <category term="树形DP" scheme="http://yoursite.com/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
  </entry>
  
  <entry>
    <title>【模板】Tarjan</title>
    <link href="http://yoursite.com/2018/10/22/%E3%80%90%E6%A8%A1%E6%9D%BF%E3%80%91Tarjan/"/>
    <id>http://yoursite.com/2018/10/22/【模板】Tarjan/</id>
    <published>2018-10-22T14:08:29.000Z</published>
    <updated>2019-08-02T05:06:51.236Z</updated>
    
    <content type="html"><![CDATA[<p>tarjan模板：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10005</span>,MAXM=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAX]=&#123;<span class="number">0</span>&#125;,low[MAX]=&#123;<span class="number">0</span>&#125;,indx=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;;</span><br><span class="line">edge g[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAX]=&#123;<span class="number">0</span>&#125;,nume=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> color[MAX]=&#123;<span class="number">0</span>&#125;,cnt[MAX]=&#123;<span class="number">0</span>&#125;,sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    g[++nume].next=head[f];</span><br><span class="line">    g[nume].to=t;</span><br><span class="line">    head[f]=nume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=++indx;</span><br><span class="line">    low[u]=indx;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    s.push(u);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=g[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=g[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        color[u]=++sum;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.top()!=u)&#123;</span><br><span class="line">            color[s.top()]=sum;</span><br><span class="line">            vis[s.top()]=<span class="number">0</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">        adde(x,y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">if</span>(dfn[i]==<span class="number">0</span>)tarjan(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        cnt[color[i]]++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=sum;i++)</span><br><span class="line">        <span class="keyword">if</span>(cnt[i]&gt;<span class="number">1</span>)ans++;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缩点：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX=<span class="number">10005</span>,MAXM=<span class="number">50005</span>;</span><br><span class="line"><span class="keyword">int</span> dfn[MAX]=&#123;<span class="number">0</span>&#125;,low[MAX]=&#123;<span class="number">0</span>&#125;,indx=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">bool</span> vis[MAX]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to;</span><br><span class="line">&#125;;</span><br><span class="line">edge g[MAXM];</span><br><span class="line"><span class="keyword">int</span> head[MAX]=&#123;<span class="number">0</span>&#125;,nume=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> color[MAX]=&#123;<span class="number">0</span>&#125;,cnt[MAX]=&#123;<span class="number">0</span>&#125;,du[MAX],sum=<span class="number">0</span>,tmp,ans;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adde</span><span class="params">(<span class="keyword">int</span> f,<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    g[++nume].next=head[f];</span><br><span class="line">    g[nume].to=t;</span><br><span class="line">    head[f]=nume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tarjan</span><span class="params">(<span class="keyword">int</span> u)</span></span>&#123;</span><br><span class="line">    dfn[u]=++indx;</span><br><span class="line">    low[u]=indx;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    s.push(u);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i!=<span class="number">-1</span>;i=g[i].next)&#123;</span><br><span class="line">        <span class="keyword">int</span> v=g[i].to;</span><br><span class="line">        <span class="keyword">if</span>(dfn[v]==<span class="number">0</span>)&#123;</span><br><span class="line">            tarjan(v);</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(vis[v])</span><br><span class="line">            low[u]=min(low[u],low[v]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line">        color[u]=++sum;</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s.top()!=u)&#123;</span><br><span class="line">            color[s.top()]=sum;</span><br><span class="line">            vis[s.top()]=<span class="number">0</span>;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        s.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(du));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(low));</span><br><span class="line">        <span class="built_in">memset</span>(dfn,<span class="number">0</span>,<span class="keyword">sizeof</span>(dfn));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(cnt));</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span>(color));</span><br><span class="line">        <span class="comment">//memset(vis,0,sizeof(stack));</span></span><br><span class="line">        <span class="keyword">while</span>(!s.empty())s.pop();</span><br><span class="line">        <span class="built_in">memset</span>(head,<span class="number">-1</span>,<span class="keyword">sizeof</span>(head));</span><br><span class="line">        nume=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> x,y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;x,&amp;y);</span><br><span class="line">            adde(x,y);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">            <span class="keyword">if</span>(dfn[i]==<span class="number">0</span>)</span><br><span class="line">                tarjan(i);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=head[i];j!=<span class="number">-1</span>;j=g[j].next)&#123;</span><br><span class="line">                <span class="keyword">int</span> v=g[j].to;</span><br><span class="line">                <span class="keyword">if</span>(color[v]!=color[i])</span><br><span class="line">                    du[color[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[color[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=sum; i++)</span><br><span class="line">            <span class="keyword">if</span>(du[i]==<span class="number">0</span>)&#123;</span><br><span class="line">                tmp++;</span><br><span class="line">                ans=cnt[i];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tmp==<span class="number">0</span>)<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tmp&gt;<span class="number">1</span>)<span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;tarjan模板：&lt;/p&gt;
    
    </summary>
    
      <category term="OI" scheme="http://yoursite.com/categories/OI/"/>
    
    
      <category term="OI" scheme="http://yoursite.com/tags/OI/"/>
    
      <category term="模板" scheme="http://yoursite.com/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="图论" scheme="http://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="Tarjan" scheme="http://yoursite.com/tags/Tarjan/"/>
    
  </entry>
  
</feed>
